[
  {
    "timestamp": "2025-09-28T11:13:32.184382",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Return the indices of two numbers in the array that add up to the target.\n    \n    :param nums: List[int] - The array of integers.\n    :param target: int - The target sum.\n    :return: List[int] - Indices of the two numbers that add up to target.\n    \"\"\"\n    # Initialize an empty dictionary to store the complement of each number\n    complement_dict = {}\n    \n    # Iterate through each element in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in complement_dict:\n            # Return the indices of the two numbers that add up to target\n            return [complement_dict[complement], i]\n        \n        # Add the current number as a key with its index to the dictionary\n        complement_dict[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Example usage:\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]",
    "code": "from typing import List, Optional\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Return the indices of two numbers in the array that add up to the target.\n    \n    :param nums: List[int] - The array of integers.\n    :param target: int - The target sum.\n    :return: List[int] - Indices of the two numbers that add up to target.\n    \"\"\"\n    complement_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complement_dict:\n            return [complement_dict[complement], i]\n        complement_dict[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:13:37.159732",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "Retry failed: 'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n\n    Example:\n        >>> two_sum([2, 7, 11, 15], 9)\n        [0, 2]\n        # Explanation: The numbers at indices 0 and 2 sum to 9.\n    \"\"\"\n    seen = set()  # Use a set to keep track of the numbers we've encountered so far\n    for i, num in enumerate(nums):\n        complement = target - num  # Calculate the complement needed to reach the target\n        if complement in seen:\n            return [seen.index(complement), i]  # Return the indices if found\n        seen.add(num)  # Add the current number to the set\n    return []  # Return an empty list if no pair is found",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n\n    Example:\n        >>> two_sum([2, 7, 11, 15], 9)\n        [0, 2]\n        # Explanation: The numbers at indices 0 and 2 sum to 9.\n    \"\"\"\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:13:47.034467",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find the indices of two numbers in the array nums that add up to the target.\n    \n    Args:\n    - nums: List[int] - A list of integers.\n    - target: int - The target sum to find.\n    \n    Returns:\n    - A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    # Dictionary to store numbers and their indices\n    num_to_index = {}\n    \n    for index, number in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - number\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_to_index:\n            return [num_to_index[complement], index]\n        \n        # If not, add the current number and its index to the dictionary\n        num_to_index[number] = index\n    \n    # Return an empty list if no pair of numbers adds up to the target\n    return []\n\n# Test cases\nprint(two_sum([1, 2, 3, 4, 5], 9))  # Output: [0, 3]\nprint(two_sum([-1, 0, 1], -1))   # Output: [0, 1]\nprint(two_sum([7, 11, 8, 12], 19)) # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find the indices of two numbers in the array nums that add up to the target.\n    \n    Args:\n    - nums: List[int] - A list of integers.\n    - target: int - The target sum to find.\n    \n    Returns:\n    - A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    num_to_index = {}\n    for index, number in enumerate(nums):\n        complement = target - number\n        if complement in num_to_index:\n            return [num_to_index[complement], index]\n        num_to_index[number] = index\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:13:57.017270",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    :param nums: List[int] - The input array of integers.\n    :param target: int - The target sum to find in the array.\n    :return: list[int] - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        else:\n            seen[num] = i",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    :param nums: List[int] - The input array of integers.\n    :param target: int - The target sum to find in the array.\n    :return: list[int] - A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        else:\n            seen[num] = i"
  },
  {
    "timestamp": "2025-09-28T11:13:59.599368",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in the array nums that add up to the target.\n    \n    Args:\n    - nums (list): A list of integers.\n    - target (int): The target sum to find.\n    \n    Returns:\n    - list[int]: A list containing the indices of the two numbers whose sum equals the target.\n    \"\"\"\n    # Dictionary to store the number and its index\n    num_index = {}\n    \n    # Iterate through each element in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_index:\n            return [num_index[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        num_index[num] = i\n    \n    # Return an empty list if no two numbers sum up to the target\n    return []",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Returns the indices of the two numbers in the array nums that add up to the target.\n    \n    Args:\n    - nums (list): A list of integers.\n    - target (int): The target sum to find.\n    \n    Returns:\n    - list[int]: A list containing the indices of the two numbers whose sum equals the target.\n    \"\"\"\n    num_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_index:\n            return [num_index[complement], i]\n        num_index[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:14:05.230818",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find the indices of two numbers in the given array 'nums' that add up to the 'target'.\n    \n    Args:\n    nums (list[int]): The array of integers.\n    target (int): The target sum of the two numbers.\n    \n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    # Create a dictionary to store numbers and their indices\n    num_index = {}\n    \n    # Iterate through each number in the array\n    for index, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_index:\n            return [num_index[complement], index]\n        \n        # If not, add the number and its index to the dictionary\n        num_index[num] = index\n    \n    # Return an empty list if no such pair exists\n    return []\n\n# Test cases to verify the function works as expected\ndef test_two_sum():\n    assert two_sum([2, 7, 11, 15], 9) == [0, 1]\n    assert two_sum([-1, 3, 5, -4], 2) == [0, 3]\n    assert two_sum([1, 3, 4, 5], 8) == [0, 3]\n    assert two_sum([], 0) == []\n    assert two_sum([5], 5) == [0]\n\n# Run the test cases\ntest_two_sum()",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find the indices of two numbers in the given array 'nums' that add up to the 'target'.\n    \n    Args:\n    nums (list[int]): The array of integers.\n    target (int): The target sum of the two numbers.\n    \n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    num_index = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in num_index:\n            return [num_index[complement], index]\n        num_index[num] = index\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:14:16.340246",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] + nums[j] == target:\n                return [i, j]\n            elif nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                i += 1",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        j = len(nums) - 1\n        while i < j:\n            if nums[i] + nums[j] == target:\n                return [i, j]\n            elif nums[i] + nums[j] > target:\n                j -= 1\n            else:\n                i += 1"
  },
  {
    "timestamp": "2025-09-28T11:14:17.962029",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    Constraints:\n        Each input has exactly one solution. Do not use the same element twice.\n\n    Examples:\n        Input: nums = [2,7,11,15], target = 9 \u2192 Output: [0,1]\n        Function name: two_sum\n    \"\"\"\n    # Create an empty dictionary to store indices of elements as values\n    hash_map = {}\n\n    # Iterate through the array and check if the complement (target - current element) exists in the hash map\n    for i in range(len(nums)):\n        complement = target - nums[i]\n\n        # Check if the complement is already in the hash map\n        if complement in hash_map:\n            return [hash_map[complement], i]\n        \n        # Otherwise, store the current index in the dictionary with the complement as the key\n        hash_map[nums[i]] = i\n\n    # If no solution is found, return None\n    return None",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    Constraints:\n        Each input has exactly one solution. Do not use the same element twice.\n\n    Examples:\n        Input: nums = [2,7,11,15], target = 9 \u2192 Output: [0,1]\n        Function name: two_sum\n    \"\"\"\n    hash_map = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in hash_map:\n            return [hash_map[complement], i]\n        hash_map[nums[i]] = i\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:14:25.211826",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "Retry failed: 'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a set to store numbers we have seen so far\n    seen = set()\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if this complement has already been seen\n        if complement in seen:\n            return [seen.index(complement), i]\n        \n        # Add the current number to the set of seen numbers\n        seen.add(num)\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([3, 2, 4, 6, 5, 8], 9))  # Output: [0, 3]\nprint(two_sum([-1, 1, -1, -5], -2))  # Output: [0, 2]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:14:35.979843",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums, target):\n    # Create a set to store numbers as we iterate through the array\n    seen_numbers = set()\n    \n    for i in range(len(nums)):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - nums[i]\n        \n        # Check if this complement has already been seen\n        if complement in seen_numbers:\n            return [seen_numbers.index(complement), i]\n        \n        # If not, add the current number to the set and continue\n        seen_numbers.add(nums[i])\n    \n    # If no such pair is found, return None\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15, 23]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: (0, 3)",
    "code": "def two_sum(nums, target):\n    seen_numbers = set()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen_numbers:\n            return [seen_numbers.index(complement), i]\n        seen_numbers.add(nums[i])\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:14:46.015740",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Dictionary to store elements and their indices\n    seen = {}\n    \n    for i in range(len(nums)):\n        # Calculate the complement needed to reach the target\n        complement = target - nums[i]\n        \n        # Check if the complement exists in the dictionary\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Add the current element to the dictionary\n        seen[nums[i]] = i\n    \n    # If no such pair is found, return None or raise an error\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3] (because nums[0] + nums[3] = 9)",
    "code": "def two_sum(nums, target):\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen[complement], i]\n        seen[nums[i]] = i\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:14:59.267126",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a dictionary to store numbers and their indices\n    num_index = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if this complement is already in the dictionary\n        if complement in num_index:\n            return [num_index[complement], i]\n        \n        # Store the current number and its index in the dictionary\n        num_index[num] = i\n    \n    # If no such pair is found, return None or an appropriate error message\n    return None\n\n# Test cases to verify the correctness of the function\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([3, 2, 4, 6], 8))  # Output: [1, 3]\nprint(two_sum([], 5))            # Output: None",
    "code": "from typing import List, Optional\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    num_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_index:\n            return [num_index[complement], i]\n        num_index[num] = i\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:15:10.551847",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n        nums (list[int]): List of integers.\n        target (int): The target sum to find in the array.\n        \n    Returns:\n        list[int]: A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    seen = {}\n    for index, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], index]\n        seen[num] = index\n    return []\n\n# Example usage:\nprint(two_sum([1, 3, 4, 5], 9))  # Output: [2, 4]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n        nums (list[int]): List of integers.\n        target (int): The target sum to find in the array.\n        \n    Returns:\n        list[int]: A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    seen = {}\n    for index, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], index]\n        seen[num] = index\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:15:15.150405",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement that would sum up to the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        seen_numbers[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:15:25.637039",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    i = 0\n    j = len(nums) - 1\n\n    while i < j:\n        current_sum = nums[i] + nums[j]\n        \n        if current_sum == target:\n            return [i, j]\n        elif current_sum < target:\n            i += 1\n        else:\n            j -= 1\n\n# Test cases\nprint(two_sum([1, 2, 3, 4, 5], 9))  # Output: [0, 1]\nprint(two_sum([1, 2, 3, 4, 5], 8))  # Output: [0, 2]\nprint(two_sum([1, 2, 3, 4, 5], 7))  # Output: [0, 3]\nprint(two_sum([1, 2, 3, 4, 5], 6))  # Output: [0, 4]\nprint(two_sum([1, 2, 3, 4, 5], 10))  # Output: [0, 4]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    i = 0\n    j = len(nums) - 1\n    while i < j:\n        current_sum = nums[i] + nums[j]\n        if current_sum == target:\n            return [i, j]\n        elif current_sum < target:\n            i += 1\n        else:\n            j -= 1"
  },
  {
    "timestamp": "2025-09-28T11:15:38.283235",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create a dictionary to store the indices of the elements as values\n    index_map = {}\n    \n    for i in range(len(nums)):\n        # Calculate the complement needed to reach the target\n        complement = target - nums[i]\n        \n        # Check if the complement exists in the dictionary\n        if complement in index_map:\n            return [index_map[complement], i]\n        \n        # If not, add the current element and its index to the dictionary\n        index_map[nums[i]] = i\n    \n    # If no two numbers sum to the target, return None or an appropriate message\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    index_map = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in index_map:\n            return [index_map[complement], i]\n        index_map[nums[i]] = i\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:15:46.667487",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Iterate through each number in the array\n    for i in range(len(nums)):\n        # Use another loop to find if there exists a number in the remaining part of the array (starting from i + 1)\n        for j in range(i + 1, len(nums)):\n            # Check if their sum equals the target\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    # Return an empty list if no such pair is found\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:15:57.072337",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Check for duplicate elements\n    if len(set(nums)) != len(nums):\n        return []\n    \n    # Iterate through the array and find the complement\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums:\n            # Return the indices of the two numbers\n            return [i, nums.index(complement)]\n    \n    # Return an empty list if no solution is found\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([4, 5, -3, 2, 6], 9))  # Output: [1, 2]",
    "code": "def two_sum(nums, target):\n    if len(set(nums)) != len(nums):\n        return []\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums:\n            return [i, nums.index(complement)]\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:16:06.859485",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen[complement], i]\n        seen[nums[i]] = i\n\nnums = [-1, 2, 3, 7, 8]\ntarget = 9\nprint(two_sum(nums, target))",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen[complement], i]\n        seen[nums[i]] = i"
  },
  {
    "timestamp": "2025-09-28T11:16:12.942922",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the array to make it easier to use the two-pointer technique\n    nums.sort()\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum < target:\n            # If the sum is less than the target, move the left pointer to the right\n            left += 1\n        else:\n            # If the sum is greater than the target, move the right pointer to the left\n            right -= 1\n    \n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nif result:\n    print(f\"The indices of the two numbers that add up to {target} are: {result}\")\nelse:\n    print(\"No two numbers add up to the target.\")",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:16:23.466685",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a dictionary to store the elements we've seen so far and their indices\n    seen = {}\n    \n    for index, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if the complement is already in our dictionary\n        if complement in seen:\n            # If it is, return the current indices and the complement's index\n            return [seen[complement], index]\n        \n        # Otherwise, add the current number and its index to the dictionary\n        seen[num] = index\n    \n    # Return an empty list if no two numbers add up to the target\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], index]\n        seen[num] = index\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:16:29.028947",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a set to store seen numbers\n    seen = set()\n    \n    # Iterate through each number in the array\n    for num in nums:\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement has already been seen\n        if complement in seen:\n            # Return the indices of the two numbers that sum up to the target\n            return [seen.index(complement), i]\n        \n        # If not, add the current number to the set and continue\n        seen.add(num)\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:16:39.200508",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    if len(nums) < 2:\n        return None\n    \n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return None\n\n# Test Cases\nassert two_sum([2, 4, 6, 8, 10], 8) == [0, 3]\nassert two_sum([-3, -2, 5, 9, 1], 7) == [1, 2]\nassert two_sum([], 5) == None\nassert two_sum([5, 5], 10) == None",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    if len(nums) < 2:\n        return None\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:16:51.961406",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    seen = {}\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement that would add up with the current number\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Add the current number to the dictionary\n        seen[num] = i\n    \n    # If no two numbers add up to the target, return None\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:17:01.756376",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the array\n    nums.sort()\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        # Calculate the sum of the numbers at the current pointers\n        current_sum = nums[left] + nums[right]\n        \n        # If the sum is equal to the target, return the indices\n        if current_sum == target:\n            return [left, right]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    return [-1, -1]  # Return [-1, -1] if no pair is found\n\n# Example usage\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return [-1, -1]"
  },
  {
    "timestamp": "2025-09-28T11:17:12.288388",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a dictionary to store numbers as keys and their indices as values\n    seen = {}\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            # Return the indices of the two numbers that add up to the target\n            return [seen[complement], i]\n        \n        # Store the current number and its index in the dictionary\n        seen[num] = i\n    \n    # If no such pair is found, return an empty list or raise an exception\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([3, 2, 4, 1], 6))   # Output: [1, 2]",
    "code": "from typing import List, Optional\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:17:22.568640",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        seen = set()\n        for num in nums:\n            if -target - num in seen:\n                return [seen.pop(), num]\n            seen.add(num)",
    "code": "\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n"
  },
  {
    "timestamp": "2025-09-28T11:17:25.598285",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\n    :param nums: List of integers.\n    :param target: Integer representing the target sum.\n    :return: A list of two integers whose sum is equal to the target, or None if no such pair exists.\n    \"\"\"\n    # Create a dictionary to store the numbers we've seen so far\n    seen_numbers = {}\n\n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement that would add up with `num` to the target\n        complement = target - num\n\n        # Check if the complement has already been seen\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # Add the current number to the dictionary\n        seen_numbers[num] = i\n\n    # If no pair is found, return None\n    return None\n\n# Example usage:\nnums = [2, 4, 7, 8, 11]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\n    :param nums: List of integers.\n    :param target: Integer representing the target sum.\n    :return: A list of two integers whose sum is equal to the target, or None if no such pair exists.\n    \"\"\"\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:17:35.484869",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    :param nums: List of integers.\n    :param target: The target sum.\n    :return: A list of indices where the two numbers add up to the target.\n    \"\"\"\n    # Initialize dictionaries to store the numbers we have seen so far and their corresponding indices\n    seen = {}\n    \n    # Iterate over each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            # Return the indices of the two numbers\n            return [seen[complement], i]\n        \n        # Store the current number and its index in the dictionary\n        seen[num] = i\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test cases\nprint(two_sum([3, 2, 4, 6], 6))  # Output: [1, 2]\nprint(two_sum([1, 2, 3, 7], 5))  # Output: [0, 3]\nprint(two_sum([-1, -2, 1], -3))  # Output: [1, 2]\nprint(two_sum([1, 3, 4], 9))  # Output: [0, 2]\nprint(two_sum([-5, -3, -1, 0, 2, 8], -6))  # Output: [2, 5]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    :param nums: List of integers.\n    :param target: The target sum.\n    :return: A list of indices where the two numbers add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:17:47.423137",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "name 'two_sum' is not defined",
    "raw_code": "return [i for i in range(len(nums)) if nums[i] + nums[target - nums[i]] == target]",
    "code": ""
  },
  {
    "timestamp": "2025-09-28T11:17:48.140310",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums: List[int]\n    - target: int\n    \n    Returns:\n    - A list of two integers where nums[i] + nums[j] == target\n    \"\"\"\n    # Create a dictionary to store the complements of each number in the array\n    complements = {}\n    \n    for index, num in enumerate(nums):\n        # Calculate the complement that would add up to the target with the current number\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in complements:\n            return [complements[complement], index]\n        \n        # If not, store the current number and its complement in the dictionary\n        complements[num] = index\n    \n    # In case no such pair exists, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 2]",
    "code": "from typing import List, Optional\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums: List[int]\n    - target: int\n    \n    Returns:\n    - A list of two integers where nums[i] + nums[j] == target\n    \"\"\"\n    complements = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], index]\n        complements[num] = index\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:17:56.779903",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize pointers at the start and end of the array\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        # If the complement is found, return the indices\n        if current_sum == target:\n            return [left, right]\n        \n        # If the current sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the current sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    return []  # Return an empty list if no solution is found\n\n# Test cases\nprint(two_sum([1, 2, 3, 4], 9))  # Output: [0, 3]\nprint(two_sum([-1, 1, 2, 3, 7], 6))  # Output: [1, 5]\nprint(two_sum([10, 22, 33, 44], 55))  # Output: []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:18:09.663076",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: list[int], target: int) -> list[int]:\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]",
    "code": "\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n"
  },
  {
    "timestamp": "2025-09-28T11:18:12.940615",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        # Create a set to store the numbers we've seen so far\n        seen = set()\n        \n        # Iterate through each number in the list\n        for num in nums:\n            # Calculate the complement needed to reach the target sum\n            complement = target - num\n            \n            # Check if the complement is already in our set\n            if complement in seen:\n                # Return the indices of the two numbers that add up to the target\n                return [seen.index(complement), i]\n            \n            # Add the current number to the set of seen numbers\n            seen.add(num)",
    "code": "\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n"
  },
  {
    "timestamp": "2025-09-28T11:18:19.234919",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []  # Initialize an empty list to store the result\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                result.append([i, j])  # Append the indices of the two numbers as a tuple to the result list\n                return result  # Return the result list\n    return []  # Return an empty list if no such elements are found\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [[0, 1], [1, 2]]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                result.append([i, j])\n                return result\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:18:35.349940",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Dictionary to store numbers and their indices\n    num_to_index = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        num_to_index[num] = i\n    \n    # Return an empty list if no two numbers sum up to the target\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([1, 2, 3, 4, 5], 8))  # Output: [1, 4]\nprint(two_sum([10, -3, 7, 14, 16], -9)) # Output: [1, 4]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:18:52.401413",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "from typing import List\n\nclass Solution:\n    def two_sum(self, nums: List[int], target: int) -> List[int]:\n        # Create a dictionary to store the numbers and their indices\n        num_indices = {}\n        \n        # Iterate through the list of numbers\n        for i, number in enumerate(nums):\n            complement = target - number\n            \n            # Check if the complement exists in the dictionary\n            if complement in num_indices:\n                return [num_indices[complement], i]\n            \n            # Add the current number and its index to the dictionary\n            num_indices[number] = i\n        \n        # If no solution is found, return an empty list\n        return []",
    "code": "\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n"
  },
  {
    "timestamp": "2025-09-28T11:19:04.067178",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            # Found a pair that adds up to the target\n            return [seen.index(complement), i]\n        \n        # Add the current number to the set of seen numbers\n        seen.add(num)\n    \n    # Return an empty list if no such pair is found\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([2, 7, 11, 15], 14))  # Output: []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:19:24.803674",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: List[int], target: int) -> List[int]:\n        # Initialize pointers to the start and end of the array\n        left = 0\n        right = len(nums) - 1\n        \n        # Iterate through the array\n        while left <= right:\n            current_sum = nums[left] + nums[right]\n            \n            # If the sum equals the target, return their indices\n            if current_sum == target:\n                return [left, right]\n            \n            # If the sum is greater than the target, move the left pointer to the right\n            elif current_sum > target:\n                left += 1\n            \n            # If the sum is less than the target, move the right pointer to the left\n            else:\n                right -= 1\n        \n        return []  # Return an empty list if no solution is found",
    "code": "\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n"
  },
  {
    "timestamp": "2025-09-28T11:19:40.227718",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize pointers left and right to the start and end of the list\n    left, right = 0, len(nums) - 1\n    \n    # Iterate through the list using two pointers\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            # If the sum is equal to the target, return the indices\n            return [left, right]\n        \n        elif current_sum < target:\n            # If the sum is less than the target, move the left pointer to the right\n            left += 1\n        else:\n            # If the sum is greater than the target, move the right pointer to the left\n            right -= 1\n    \n    # Return an empty list if no pair is found\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([-1, 3, 4, 1, 5], 5)) # Output: [1, 2]\nprint(two_sum([1, 2, 3, 4, 5], 6)) # Output: [2, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:19:54.903274",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        seen_numbers[num] = i\n    \n    # If no two numbers sum to the target, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:20:02.407099",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    The order of these numbers does not matter.\n    \n    :param nums: List of integers\n    :param target: Integer target\n    :return: Indices of the two numbers that add up to target\n    \"\"\"\n    # Create a dictionary to store the numbers we've seen so far\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n    \n        # Check if the complement exists in our dictionary\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Add the current number to the dictionary\n        seen[num] = i\n    \n    # If no such pair is found, return None or raise an exception (not practical for this problem)\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1] since nums[0] + nums[1] = 9",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    The order of these numbers does not matter.\n    \n    :param nums: List of integers\n    :param target: Integer target\n    :return: Indices of the two numbers that add up to target\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:20:16.459321",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test Cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([1, 3, 5, 7], 12))  # Output: [0, 2]\nprint(two_sum([-1, 1, -4, 1], -3))  # Output: [0, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:20:30.050351",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: List[int], target: int) -> List[int]:\n        seen = set()\n        \n        for i in range(len(nums)):\n            complement = target - nums[i]\n            \n            if complement in seen:\n                return [seen[complement], i]\n            \n            seen.add(nums[i])",
    "code": "\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n"
  },
  {
    "timestamp": "2025-09-28T11:20:33.250883",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Function signature: def two_sum(nums: list[int], target: int -> list[int])\n    \n    This function takes a list of integers `nums` and an integer `target`, then returns the indices of the two numbers in `nums`\n    that add up to `target`. If no such pair exists, it returns [-1] if there are multiple pairs.\n    \n    Explanation:\n        - The function initializes two pointers, one at the start (0) and one at the end of the list (len(nums)-1).\n        - It then iterates through the list using these pointers. For each element, it calculates the complement that would sum up to the target.\n        - If the complement is found in the remaining part of the list (i.e., `nums[i] + nums[j] == target`), the function returns a list containing the indices of the two numbers.\n        - If no such pair is found after checking all elements, the function returns [-1].\n    \"\"\"",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Function signature: def two_sum(nums: list[int], target: int -> list[int])\n    \n    This function takes a list of integers `nums` and an integer `target`, then returns the indices of the two numbers in `nums`\n    that add up to `target`. If no such pair exists, it returns [-1] if there are multiple pairs.\n    \n    Explanation:\n        - The function initializes two pointers, one at the start (0) and one at the end of the list (len(nums)-1).\n        - It then iterates through the list using these pointers. For each element, it calculates the complement that would sum up to the target.\n        - If the complement is found in the remaining part of the list (i.e., `nums[i] + nums[j] == target`), the function returns a list containing the indices of the two numbers.\n        - If no such pair is found after checking all elements, the function returns [-1].\n    \"\"\""
  },
  {
    "timestamp": "2025-09-28T11:20:47.388252",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        complement = target - nums[left]\n        \n        if complement in nums[right:]:\n            return [left, right]\n        else:\n            left += 1\n            \n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        complement = target - nums[left]\n        if complement in nums[right:]:\n            return [left, right]\n        else:\n            left += 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:20:56.798617",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty list to store the indices of the complement\n    indices = []\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement that would add up with the current number\n        complement = target - num\n        \n        # Check if the complement exists in the list\n        if complement in indices:\n            return [indices.index(complement), i]\n        \n        # If not, add the current number to the list of indices\n        indices.append(i)\n    \n    # Return an empty list if no two numbers add up to the target\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    indices = []\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in indices:\n            return [indices.index(complement), i]\n        indices.append(i)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:21:06.745853",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a dictionary to store numbers and their indices\n    num_to_index = {}\n    \n    # Iterate through the array\n    for i, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        \n        # Otherwise, add the current number and its index to the dictionary\n        num_to_index[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([3, 2, 4, 1], 6))  # Output: [1, 2]\nprint(two_sum([-1, -2, 3, 4, 5], 7))  # Output: [1, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:21:16.399256",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(arr: list[int], target: int) -> list[int]:\n    \"\"\"\n    This function takes a list of integers and an integer target as input.\n    It returns the indices of the two numbers in the list that sum up to the target.\n    Example:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return [i, j]",
    "code": "def two_sum(arr: list[int], target: int) -> list[int]:\n    \"\"\"\n    This function takes a list of integers and an integer target as input.\n    It returns the indices of the two numbers in the list that sum up to the target.\n    Example:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    \"\"\"\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == target:\n                return [i, j]"
  },
  {
    "timestamp": "2025-09-28T11:21:18.899303",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(arr,n):\n    for i in range(0,len(arr)):\n        for j in range(i+1,len(arr)):\n            if arr[i]+arr[j]==n:\n                return [i,j]",
    "code": "def two_sum(arr, n):\n    for i in range(0, len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] + arr[j] == n:\n                return [i, j]"
  },
  {
    "timestamp": "2025-09-28T11:21:21.495729",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the list to make it easier to use a two-pointer technique\n    nums.sort()\n    \n    # Initialize pointers for the start and end of the list\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        # Calculate the sum of elements at the current pointers\n        sum_of_elements = nums[left] + nums[right]\n        \n        # If the sum is equal to the target, return the pair [left, right]\n        if sum_of_elements == target:\n            return [nums[left], nums[right]]\n        \n        # If the sum is greater than the target, move the left pointer to the right\n        elif sum_of_elements > target:\n            right -= 1\n        \n        # If the sum is less than the target, move the right pointer to the left\n        else:\n            left += 1\n    \n    # If no pair is found, return an empty list or raise an error if necessary\n    return []\n\n# Test cases to verify the correctness of the function\nassert two_sum([2,7,11,15], 9) == [0,1]\nassert two_sum([-3,4,6,10,15], 9) == [2,7]\nassert two_sum([1,2,3,4,5,6], 9) == [2,7]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        sum_of_elements = nums[left] + nums[right]\n        if sum_of_elements == target:\n            return [nums[left], nums[right]]\n        elif sum_of_elements > target:\n            right -= 1\n        else:\n            left += 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:21:28.813505",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]"
  },
  {
    "timestamp": "2025-09-28T11:21:29.977869",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a set to store the numbers we have seen so far\n    seen_numbers = set()\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Calculate the complement that would sum up with the current number\n        complement = target - num\n        \n        # Check if this complement exists in our set of seen numbers\n        if complement in seen_numbers:\n            return [seen_numbers.pop(), num]\n        \n        # Add the current number to the set of seen numbers\n        seen_numbers.add(num)\n    \n    # If no pair is found, return an empty list or raise an exception\n    return []\n\n# Test cases\nassert two_sum([2,7,11,15], 9) == [0,1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers.pop(), num]\n        seen_numbers.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:21:37.670254",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Use the complement of the current number (target - num) to find another number in the list\n        complement = target - num\n        \n        # Check if the complement exists in the list\n        if complement in nums:\n            # If found, add the pair [num] and [complement] to the result list\n            result.append([num, complement])\n    \n    return result\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    for num in nums:\n        complement = target - num\n        if complement in nums:\n            result.append([num, complement])\n    return result"
  },
  {
    "timestamp": "2025-09-28T11:21:44.783673",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums,target):\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            if nums[i]+nums[j]==target:\n                return [i,j]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]"
  },
  {
    "timestamp": "2025-09-28T11:21:45.788036",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "# Define the function two_sum that takes an array and a target as input.\ndef two_sum(arr, target):\n    # Initialize an empty list to store the indices of elements in the array.\n    res = []\n    # Iterate through each element in the array using a for loop.\n    for i in range(len(arr)):\n        # Calculate the complement of the current element with respect to the target.\n        complement = target - arr[i]\n        # Check if the complement exists in the array.\n        if complement in arr:\n            # If it does, append the index of the complement and its corresponding element to the result list.\n            res.append([arr.index(complement), i])\n    # Return the result list containing the indices of the elements that sum up to the target.\n    return res",
    "code": "def two_sum(arr, target):\n    res = []\n    for i in range(len(arr)):\n        complement = target - arr[i]\n        if complement in arr:\n            res.append([arr.index(complement), i])\n    return res"
  },
  {
    "timestamp": "2025-09-28T11:21:48.797568",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "# Define the function to find the pair that sums up to a specific target number\ndef two_sum(nums, target):\n    # Create a set to store unique numbers we have seen so far\n    seen_numbers = set()\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Calculate the complement of the current number (target - num)\n        complement = target - num\n        \n        # Check if this complement has already been seen\n        if complement in seen_numbers:\n            return [seen_numbers.pop(), num]\n        \n        # Add the current number to the set of seen numbers\n        seen_numbers.add(num)\n    \n    # If no such pair is found, return None (though in this case, we know a solution exists)\n    return None\n\n# Test cases to verify the correctness of the two_sum function\nassert two_sum([2,7,11,15], 9) == [0,1]\nassert two_sum([3,2,4,6,5,11,7], 10) == [2,8]\nassert two_sum([1,2,3,4,5,6], 11) == [2,3]",
    "code": "def two_sum(nums, target):\n    seen_numbers = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers.pop(), num]\n        seen_numbers.add(num)\n    return None"
  },
  {
    "timestamp": "2025-09-28T11:21:55.380022",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create an empty list to store the pair of numbers\n    result = []\n    \n    # Iterate through each number in the list\n    for i in range(len(nums)):\n        # Check if there exists another number in the list that would sum with nums[i] with the current target\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                # If a pair is found, add it to the result list\n                result.append([nums[i], nums[j]])\n    \n    return result\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    result = []\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                result.append([nums[i], nums[j]])\n    return result"
  },
  {
    "timestamp": "2025-09-28T11:22:06.550607",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum < target:\n            left += 1\n        \n        else:\n            right -= 1\n    \n    return []\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([1, 3, 2, 4], 8) == []\nassert two_sum([1, 3, -2, 1], -1) == [0, 2]",
    "code": "def two_sum(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:22:17.325816",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize two pointers: left pointer at the start and right pointer at the end of the list\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        # Calculate the complement of the current element with respect to the target\n        complement = target - nums[left]\n        \n        # Check if the complement is in the remaining part of the list\n        if complement in nums[right:]:\n            return [nums[left], nums[right]]\n        else:\n            # Move the pointer that points to the smaller number\n            if nums[left] < nums[right]:\n                left += 1\n            else:\n                right -= 1\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2,7,11,15], 9) == [0,1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        complement = target - nums[left]\n        if complement in nums[right:]:\n            return [nums[left], nums[right]]\n        elif nums[left] < nums[right]:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:22:29.226241",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Sort the list to use the two-pointer technique\n    nums.sort()\n    \n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        # Calculate the sum of the numbers at the current pointers\n        total_sum = nums[left] + nums[right]\n        \n        # Check if the total sum matches the target\n        if total_sum == target:\n            return [nums[left], nums[right]]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif total_sum < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    # If no two numbers add up to the target, return an empty list or raise an error\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    nums.sort()\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        total_sum = nums[left] + nums[right]\n        if total_sum == target:\n            return [nums[left], nums[right]]\n        elif total_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:22:38.301657",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}  # Dictionary to store numbers we've encountered so far\n\n    for i, num in enumerate(nums):\n        complement = target - num  # Calculate the complement with respect to the target sum\n\n        if complement in seen:\n            return [seen[complement], i]  # Return the indices of these two numbers\n\n        seen[num] = i  # Add the current number and its complement to the dictionary",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i"
  },
  {
    "timestamp": "2025-09-28T11:22:45.039277",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Iterate through each element in the list\n    for i in range(len(nums)):\n        # Check if the complement of the current element is already in the list\n        if (target - nums[i]) in nums:\n            # Return the indices of these two elements\n            return [i, nums.index(target - nums[i])]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        if target - nums[i] in nums:\n            return [i, nums.index(target - nums[i])]"
  },
  {
    "timestamp": "2025-09-28T11:22:46.632768",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Iterate through each element in the list\n    for i in range(len(nums)):\n        # Check if there exists a complement that adds up with the current element\n        complement = target - nums[i]\n        \n        # If the complement is found, return it as the solution\n        if complement in nums:\n            return [i, nums.index(complement)]\n    \n    # Return an empty list if no solution is found\n    return []\n\n# Test cases to verify the correctness of the function\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums:\n            return [i, nums.index(complement)]\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:22:54.958750",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize an empty list to store the possible pairs\n    pairs = []\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Calculate the complement with respect to the target\n        complement = target - num\n        \n        # Check if this complement exists in the list\n        if complement in nums:\n            # Add the pair (num and its complement) to the result list\n            pairs.append([num, complement])\n    \n    return pairs\n\n# Test cases to verify the correctness of the function\nassert two_sum([2,7,11,15], 9) == [0, 1]\nassert two_sum([-2,3,4,2], 6) == [0, 2]\nassert two_sum([], 7) == []",
    "code": "def two_sum(nums, target):\n    pairs = []\n    for num in nums:\n        complement = target - num\n        if complement in nums:\n            pairs.append([num, complement])\n    return pairs"
  },
  {
    "timestamp": "2025-09-28T11:23:04.311130",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums,target):\n    # Create an empty list to store the result\n    res = []\n    # Iterate through each number in the array\n    for i in nums:\n        # Check if there exists a complement that sums up to the target\n        if (target - i) in nums:\n            # Append the pair of numbers to the result list\n            res.append((i, target - i))\n    return res",
    "code": "def two_sum(nums, target):\n    res = []\n    for i in nums:\n        if target - i in nums:\n            res.append((i, target - i))\n    return res"
  },
  {
    "timestamp": "2025-09-28T11:23:06.045688",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize two pointers: left and right\n    left = 0\n    right = len(nums) - 1\n    \n    # Loop until the left pointer is less than the right pointer\n    while left < right:\n        # Calculate the sum of the numbers at the left and right pointers\n        current_sum = nums[left] + nums[right]\n        \n        # Check if the current sum equals the target\n        if current_sum == target:\n            return [left, right]  # Return the indices where the pair is found\n        elif current_sum < target:\n            # If the current sum is less than the target, move the left pointer to the right\n            left += 1\n        else:\n            # If the current sum is greater than the target, move the right pointer to the left\n            right -= 1\n    \n    # Return an empty list if no such pair exists\n    return []\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:23:15.194166",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create an empty dictionary to store numbers and their indices\n    d = {}\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in d:\n            return [d[complement], i]\n        \n        # Store the current number and its index in the dictionary\n        d[num] = i\n    \n    # If no solution is found, return a message indicating failure\n    return \"No solution\"\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 4, -1, 2], 6) == [1, 3]\nassert two_sum([1, 2, 3, 4], 8) == [-1, 3]\nassert two_sum([1, 2, 3, 4], 7) == \"No solution\"",
    "code": "def two_sum(nums, target):\n    d = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in d:\n            return [d[complement], i]\n        d[num] = i\n    return 'No solution'"
  },
  {
    "timestamp": "2025-09-28T11:23:27.205759",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Dictionary to store numbers we have seen\n    num_dict = {}\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement with respect to the current number\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_dict:\n            # If found, return their indices\n            return [num_dict[complement], i]\n        \n        # Add the current number to the dictionary\n        num_dict[num] = i\n    \n    # Return an empty list if no two numbers add up to the target\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:23:46.918869",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Finds the indices of two numbers in the input list that add up to the target value.\n    \n    Parameters:\n        nums (list[int]): The list of integers to search through.\n        target (int): The target sum to find within the list.\n        \n    Returns:\n        list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    # Create a set to store seen numbers for O(1) average time complexity lookups\n    seen = set()\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Check if the complement (target - current number) is already in the set\n        if target - num in seen:\n            return [seen.index(target - num), i]\n        \n        # Add the current number to the set to keep track of seen numbers\n        seen.add(num)\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Finds the indices of two numbers in the input list that add up to the target value.\n    \n    Parameters:\n        nums (list[int]): The list of integers to search through.\n        target (int): The target sum to find within the list.\n        \n    Returns:\n        list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = set()\n    for i, num in enumerate(nums):\n        if target - num in seen:\n            return [seen.index(target - num), i]\n        seen.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:23:52.816124",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Initialize pointers\n    left = 0\n    right = len(nums) - 1\n    \n    # Iterate through the list using Two-Pointer Technique\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]  # Return indices of the two numbers\n        \n        elif current_sum < target:\n            left += 1  # Increase the sum by moving the left pointer to the right\n        else:\n            right -= 1  # Decrease the sum by moving the right pointer to the left\n    \n    # If no solution is found, return an empty list or a message indicating that no solution is possible\n    return []\n\n# Example usage:\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]",
    "code": "from typing import List, Optional\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:24:02.410542",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "'set' object is not subscriptable",
    "raw_code": "def two_sum(nums, target):\n    seen = set()  # Set to store elements and their indices\n    for i, num in enumerate(nums):  # Iterate through each element in the array\n        complement = target - num  # Calculate the complement of the current element\n        if complement in seen:  # Check if the complement is already in the set\n            return [seen[complement], i]  # Return the indices of the two elements that add up to the target sum\n        seen.add(num)  # Add the current element to the set\n    return []\n\n# Test cases to verify the correctness of the function\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen.add(num)\n    return []"
  },
  {
    "timestamp": "2025-09-28T11:24:10.791425",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums, target):\n    seen = set()\n    \n    for i in range(len(nums)):\n        complement = target - nums[i]\n        \n        # Check if the complement has already been encountered\n        if complement in seen:\n            return (seen.index(complement), i)\n        \n        # Add the current number to the set\n        seen.add(nums[i])\n    \n    return ()\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([4, 3, 2, 6, 5, 1], 8) == [2, 4]\nassert two_sum([1, 3, -2, 1, 1], 0) == [-1, 1]",
    "code": "def two_sum(nums, target):\n    seen = set()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return (seen.index(complement), i)\n        seen.add(nums[i])\n    return ()"
  },
  {
    "timestamp": "2025-09-28T15:30:19.775776",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers `nums` and an integer `target`, return the indices of the two numbers\n    such that they add up to `target`.\n    \n    :param nums: List[int] - The input list of integers.\n    :param target: int - The target sum to be found.\n    :return: A list of two integers, with the first element being the index of the first number in the array\n             and the second element being the index of the second number that adds up to `target`.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers `nums` and an integer `target`, return the indices of the two numbers\n    such that they add up to `target`.\n    \n    :param nums: List[int] - The input list of integers.\n    :param target: int - The target sum to be found.\n    :return: A list of two integers, with the first element being the index of the first number in the array\n             and the second element being the index of the second number that adds up to `target`.\n    \"\"\"\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:30:24.098628",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> List[int]:\n    \"\"\"\n    Finds the indices of two elements in the given array nums that sum up to the target.\n    \n    :param nums: List[int] - A list of integers.\n    :param target: int - The target sum to find in the array.\n    :return: List[int] - A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    seen = set()  # Set to keep track of numbers we have seen so far\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    \n    raise ValueError(\"No two numbers add up to the target\")",
    "code": "def two_sum(nums: list[int], target: int) -> List[int]:\n    \"\"\"\n    Finds the indices of two elements in the given array nums that sum up to the target.\n    \n    :param nums: List[int] - A list of integers.\n    :param target: int - The target sum to find in the array.\n    :return: List[int] - A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    raise ValueError('No two numbers add up to the target')",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:30:32.125672",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Finds the indices of the two numbers in the given list 'nums' that add up to 'target'.\n\n    Parameters:\n    - nums: List[int] - The list of integers to search through.\n    - target: int - The target sum to find.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target. If no such pair exists, returns an empty list.\n\n    Examples:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 3]\n    >>> two_sum([-1, -2, 1], -3)\n    [0, 1]\n    \"\"\"\n    # Create a dictionary to store the numbers we've seen so far\n    seen = {}\n    for index, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], index]\n        seen[num] = index\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 3]\nassert two_sum([-1, -2, 1], -3) == [0, 1]\nassert two_sum([1, 4, 6, 9], 10) == [1, 3]\nassert two_sum([1, 5, 7], 8) == [0, 1]",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Finds the indices of the two numbers in the given list 'nums' that add up to 'target'.\n\n    Parameters:\n    - nums: List[int] - The list of integers to search through.\n    - target: int - The target sum to find.\n\n    Returns:\n    - A list containing the indices of the two numbers that add up to the target. If no such pair exists, returns an empty list.\n\n    Examples:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 3]\n    >>> two_sum([-1, -2, 1], -3)\n    [0, 1]\n    \"\"\"\n    seen = {}\n    for index, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], index]\n        seen[num] = index",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:30:40.310286",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Iterate through each element in the array\n    for i in range(len(nums)):\n        # Calculate the complement of the current element with respect to the target\n        complement = target - nums[i]\n        \n        # Check if the complement exists in the remaining part of the array\n        if complement in nums[i + 1:]:\n            return [i, nums.index(complement)]\n    return []\n\n# Example usage:\nnums = [-3, 2, 4, 5]\ntarget = 7\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 2] or [1, 2]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums[i + 1:]:\n            return [i, nums.index(complement)]\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:30:45.007192",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n    \n    Args:\n    nums (list[int]): The list of integers to search through.\n    target (int): The target sum we are looking for.\n    \n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    # Create a dictionary to store the numbers and their indices\n    seen_numbers = {}\n    \n    # Iterate over each number in the array\n    for index, num in enumerate(nums):\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen_numbers:\n            return [seen_numbers[complement], index]\n        \n        # If not found, add the current number and its index to the dictionary\n        seen_numbers[num] = index\n    \n    # Return an empty list if no solution is found\n    return []\n\n# Example usage:\nnums1 = [2, 7, 11, 15]\ntarget1 = 9\nprint(two_sum(nums1, target1))  # Output: [0, 2]\n\nnums2 = [3, 2, 4, 6]\ntarget2 = 6\nprint(two_sum(nums2, target2))  # Output: [1, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n    \n    Args:\n    nums (list[int]): The list of integers to search through.\n    target (int): The target sum we are looking for.\n    \n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], index]\n        seen_numbers[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:30:54.076135",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a dictionary to store numbers and their indices\n    seen_numbers = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen_numbers:\n            # Return the indices of the two numbers\n            return [seen_numbers[complement], i]\n        \n        # Add the current number and its index to the dictionary\n        seen_numbers[num] = i\n    \n    # If no such pair is found, return None or an error message\n    return None\n\n# Test cases to verify the correctness of the function\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([3, 2, 4, 6, 7], 8) == [1, 2]\nassert two_sum([-1, -2, 1, -5], -4) == [3, 4]\nassert two_sum([1, 2, 3, 4, 5], 9) == None",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:31:04.709728",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]",
    "code": "def two_sum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:31:07.847339",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    for i, num in enumerate(nums):\n        # Calculate the complement (i.e., the number needed to reach the target)\n        complement = target - num\n        \n        # Check if this complement is already in the list of numbers\n        if complement in nums[i+1:]:\n            return [nums.index(complement), i]\n    \n    # If no such pair is found, return None or handle as per requirements\n    return None",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in nums[i + 1:]:\n            return [nums.index(complement), i]\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          1,
          0
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:31:14.081375",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution(object):\n    def two_sum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        length = len(nums)\n        \n        # Create a hashmap to store numbers and their indices\n        hash_table = {}\n        \n        for i in range(length): \n            if (target - nums[i]) not in hash_table:\n                hash_table[nums[i]] = i\n            else:\n                return [hash_table[target - nums[i]], i]",
    "code": "def two_sum(self, nums, target):\n    \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n    length = len(nums)\n    hash_table = {}\n    for i in range(length):\n        if target - nums[i] not in hash_table:\n            hash_table[nums[i]] = i\n        else:\n            return [hash_table[target - nums[i]], i]\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:31:22.829845",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    start, end = 0, len(nums) - 1\n    \n    while start < end:\n        current_sum = nums[start] + nums[end]\n        \n        if current_sum == target:\n            return [start, end]\n        \n        elif current_sum > target:\n            end -= 1\n        else:\n            start += 1\n    \n    # If no solution is found, return an empty list or raise an exception\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15, 3]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 4]",
    "code": "def two_sum(nums, target):\n    start, end = (0, len(nums) - 1)\n    while start < end:\n        current_sum = nums[start] + nums[end]\n        if current_sum == target:\n            return [start, end]\n        elif current_sum > target:\n            end -= 1\n        else:\n            start += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:31:34.337021",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "# Define the two_sum function with parameters: \n# - nums: List[int]\n# - target: int\n\ndef two_sum(nums, target):\n    # Initialize an empty list to store the result (index pairs)\n    res = []\n    \n    # Iterate through each element in the input list\n    for i in range(len(nums)):\n        # Calculate the complement of the current element with respect to the target\n        complement = target - nums[i]\n        \n        # Check if the complement exists in the list\n        if complement in nums:\n            # If found, append a tuple containing the index of the element and the complement\n            res.append((i, nums.index(complement)))\n    \n    return res\n\n# Example usage of the two_sum function\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\n\nprint(result)  # Output: [(0, 1), (1, 3)]",
    "code": "def two_sum(nums, target):\n    res = []\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums:\n            res.append((i, nums.index(complement)))\n    return res",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          [
            0,
            1
          ],
          [
            1,
            0
          ]
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:31:43.189398",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Dictionary to store numbers and their indices\n    seen = {}\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement needed\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            # Return the indices of the two numbers\n            return [seen[complement], i]\n        \n        # Otherwise, add the number and its index to the dictionary\n        seen[num] = i\n    \n    # If no solution is found, return None or an appropriate error message\n    return None\n\n# Test cases\nprint(two_sum([3, 2, 4, 1, 5], 9))  # Output: [0, 3]\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [1, 2]\nprint(two_sum([1, 3, 5, 7], 6))   # Output: [2, 4]",
    "code": "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:31:53.662004",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize an empty dictionary to store numbers and their indices\n    seen_numbers = {}\n    \n    # Iterate over each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen_numbers:\n            # Return the indices of the two numbers that add up to the target\n            return [seen_numbers[complement], i]\n        \n        # If not, add the number and its index to the dictionary\n        seen_numbers[num] = i\n    \n    # Return an empty list if no such pair is found\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:32:04.361254",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()  # Use a set to store elements we have seen so far\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            return (seen.index(complement), i)\n        \n        seen.add(num)  # Add the current element to the set",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return (seen.index(complement), i)\n        seen.add(num)",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:32:22.751635",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "name 'two_sum' is not defined",
    "raw_code": "def test_two_sum():\n    assert two_sum([1, 3, 2, 4], 6) == [0, 1], \"Test case 1 failed\"\n    assert two_sum([-1, 1, -5, 4], -4) == [0, 3], \"Test case 2 failed\"\n    assert two_sum([7, 9, 1, 0, 6], 8) == [1, 4], \"Test case 3 failed\"\n    assert two_sum([1, 3, 5, 0], -1) == None, \"Test case 4 failed\"\n    assert two_sum([], 0) is None, \"Test case 5 failed\"\n    print(\"All test cases passed!\")\n\n# Run the tests\ntest_two_sum()",
    "code": "",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:32:38.151210",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a dictionary to store numbers as keys and their indices as values\n    num_index = {}\n    \n    # Iterate through each number in the array\n    for index, num in enumerate(nums):\n        # Calculate the complement of the target number with the current number\n        complement = target - num\n        \n        # Check if the complement is already present in the dictionary\n        if complement in num_index:\n            # Return the indices where the two numbers add up to the target\n            return [num_index[complement], index]\n        \n        # If not, store the current number and its index in the dictionary\n        num_index[num] = index\n    \n    # If no such pair is found, return an empty list indicating that there are no solutions\n    return []",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    num_index = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in num_index:\n            return [num_index[complement], index]\n        num_index[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:32:43.865695",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Iterate through each number in the array\n    for i in range(len(nums)):\n        # Check if there exists another element in the array that adds up to the target\n        j = len(nums) - 1\n        while j > i:\n            current_sum = nums[i] + nums[j]\n            if current_sum == target:\n                return [i, j]\n            elif current_sum < target:\n                j -= 1\n            else:\n                i += 1\n    # If no such element is found after checking all elements, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        j = len(nums) - 1\n        while j > i:\n            current_sum = nums[i] + nums[j]\n            if current_sum == target:\n                return [i, j]\n            elif current_sum < target:\n                j -= 1\n            else:\n                i += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:32:56.333539",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create an empty dictionary to store numbers and their indices\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # If not found, add the current number and its index to the dictionary\n        seen[num] = i\n    \n    # Return None if no such pair is found\n    return None\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([3, 2, 4, 6], 8))   # Output: [1, 2]\nprint(two_sum([1, 3, 5, 7], 12))  # Output: [1, 2]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:33:14.542322",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    nums.sort()  # Sort the array in ascending order\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    \n    return None  # No solution exists\n\n# Example usage:\nnums = [-3, 4, 6, 7, 2, -5]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:33:31.793701",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize pointers\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(\"Indices of the two numbers that add up to\", target, \"are:\", result)",
    "code": "def two_sum(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:33:45.885754",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers that add up to target.\n    \n    :param nums: List[int] - The list of integers to search through.\n    :param target: int - The target sum to find.\n    :return: A tuple of two integers representing the indices of the two numbers that sum up to target.\n    \"\"\"\n    # Create a dictionary to store the complement of each number\n    complements = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in complements:\n            return (complements[complement], i)\n        \n        # Store the current number as a key and its index as the value in the dictionary\n        complements[num] = i\n    \n    # If no two numbers add up to the target, return None\n    return None\n\n# Test cases\ndef test_two_sum():\n    # Test case 1: Example 1\n    nums1 = [2, 7, 11, 15]\n    target1 = 9\n    result1 = two_sum(nums1, target1)\n    print(result1)  # Output: (0, 2)\n\n    # Test case 2: Example 2\n    nums2 = [-1, -4, 3, 6, 8]\n    target2 = 7\n    result2 = two_sum(nums2, target2)\n    print(result2)  # Output: (2, 5)\n\n# Run the tests\ntest_two_sum()",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers that add up to target.\n    \n    :param nums: List[int] - The list of integers to search through.\n    :param target: int - The target sum to find.\n    :return: A tuple of two integers representing the indices of the two numbers that sum up to target.\n    \"\"\"\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return (complements[complement], i)\n        complements[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:33:57.856026",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize pointers\n    left = 0\n    right = len(nums) - 1\n    \n    # Iterate through the list using two pointers\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            # Return indices of the two numbers\n            return [left, right]\n        \n        elif current_sum > target:\n            # Decrement the pointer to reduce the sum\n            right -= 1\n        \n        else:\n            # Increment the pointer to increase the sum\n            left += 1\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 4, 6, 8, 9]\ntarget = 10\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3] or [3, 0]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:34:06.725945",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    :param nums: List of integers.\n    :param target: The target sum.\n    :return: A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    # Iterate through each number in the array\n    for i, num1 in enumerate(nums):\n        # Calculate the complement that would sum with num1 to reach the target\n        complement = target - num1\n        \n        # Check if the complement exists in the remaining part of the array\n        if complement in nums[i + 1:]:\n            return [i, i + 1 + nums.index(complement)]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    :param nums: List of integers.\n    :param target: The target sum.\n    :return: A list containing the indices of the two numbers that add up to target.\n    \"\"\"\n    for i, num1 in enumerate(nums):\n        complement = target - num1\n        if complement in nums[i + 1:]:\n            return [i, i + 1 + nums.index(complement)]",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          2
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:34:16.061202",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Sort the array to make it easier to use the Two-Pointer Technique\n    nums.sort()\n    \n    # Initialize pointers\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            # Found a pair that sums to the target\n            return [left, right]\n        \n        elif current_sum < target:\n            # Move the left pointer to the right to increase the sum\n            left += 1\n        else:\n            # Move the right pointer to the left to decrease the sum\n            right -= 1\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test Cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([1, 3, 4, 8], 12))  # Output: [1, 2]\nprint(two_sum([-1, 0, 1, 2], -3))  # Output: [1, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    nums.sort()\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:34:29.030002",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution(object):\n    def two_sum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        seen = set()\n        for i in range(len(nums)):\n            if (target - nums[i]) in seen:\n                return [seen[target - nums[i]],i]\n            seen.add(nums[i])",
    "code": "def two_sum(self, nums, target):\n    \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n    seen = set()\n    for i in range(len(nums)):\n        if target - nums[i] in seen:\n            return [seen[target - nums[i]], i]\n        seen.add(nums[i])\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:34:30.752550",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Iterate through the array using two pointers\n    left, right = 0, len(nums) - 1\n    \n    # While the left pointer is less than or equal to the right pointer\n    while left <= right:\n        # Calculate the sum of the elements at the current pointers\n        current_sum = nums[left] + nums[right]\n        \n        # If the sum equals the target, return the indices\n        if current_sum == target:\n            return [left, right]\n        \n        # If the sum is greater than the target, move the left pointer to the right\n        elif current_sum > target:\n            left += 1\n        \n        # If the sum is less than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    # If no solution is found, return None or raise an error\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    left, right = (0, len(nums) - 1)\n    while left <= right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            left += 1\n        else:\n            right -= 1\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": null,
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:34:42.755847",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize an empty dictionary to keep track of the numbers we've encountered so far\n    seen = {}\n    \n    for i in range(len(nums)):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - nums[i]\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], i]  # Return the indices of the two numbers\n    \n        # Otherwise, add the current number to the dictionary and continue searching\n        seen[nums[i]] = i\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([3, 2, -4, 6], 8))   # Output: [0, 2]",
    "code": "def two_sum(nums, target):\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen[complement], i]\n        seen[nums[i]] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:34:53.337269",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "name 'two_sum' is not defined",
    "raw_code": "return [i for i in range(len(nums)) if 0 in (nums[i] + nums[other] for other in range(i+1))]",
    "code": "",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:34:54.087012",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    :param nums: List of integers.\n    :param target: Integer to be found in the array.\n    :return: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    # Create a dictionary to store the elements and their corresponding indices\n    seen = {}\n    \n    for index, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], index]\n        \n        # Add the current number and its index to the dictionary\n        seen[num] = index\n    \n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 2]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n    :param nums: List of integers.\n    :param target: Integer to be found in the array.\n    :return: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], index]\n        seen[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:35:02.649737",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Add the current number to the map\n        seen[num] = i\n    \n    # If no two numbers add up to the target, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:35:09.573202",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        seen = set()\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in seen:\n                return [seen.index(complement), i]\n            seen.add(nums[i])",
    "code": "def two_sum(self, nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(nums[i])\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:35:10.870494",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    # Initialize an empty dictionary to store the complements of numbers\n    complements = {}\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if this complement already exists in the dictionary\n        if complement in complements:\n            return [complements[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        complements[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:35:15.889222",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Sort the array to make it easier to use the two-pointer technique\n    nums.sort()\n    \n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    return []  # Return an empty list if no two numbers add up to the target\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([1, 2, 4, 6, 10], 12))  # Output: [3, 5]\nprint(two_sum([1, -1, 1], 0))   # Output: [0, 1]\nprint(two_sum([-1, -2, 1], 0))  # Output: [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    nums.sort()\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:35:28.194538",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "'set' object is not subscriptable",
    "raw_code": "def two_sum(nums, target):\n    seen = set()\n    for i in range(len(nums)):\n        if nums[i] in seen:\n            return [i, seen[nums[i]]]\n        seen.add(target - nums[i])",
    "code": "def two_sum(nums, target):\n    seen = set()\n    for i in range(len(nums)):\n        if nums[i] in seen:\n            return [i, seen[nums[i]]]\n        seen.add(target - nums[i])",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:35:39.737629",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()  # A set to store numbers we have seen so far\n\n    for num in nums:\n        complement = target - num  # Calculate the complement needed to reach the target\n\n        if complement in seen:\n            return [seen.index(complement), nums.index(num)]  # Return the indices of the two numbers\n        else:\n            seen.add(num)  # Add the current number to the set\n\n    return []  # If no solution is found, return an empty list",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), nums.index(num)]\n        else:\n            seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:35:47.482736",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Dictionary to store numbers and their indices\n    seen = {}\n    \n    # Iterate through each element in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement with respect to target\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Store the current number and its index in the dictionary\n        seen[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15, 4]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:35:57.069830",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    \n    for i in range(len(nums)):\n        complement = target - nums[i]\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [i, seen[complement]]\n        \n        # Otherwise, add the current number and its index to the dictionary\n        seen[nums[i]] = i\n    \n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [i, seen[complement]]\n        seen[nums[i]] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          1,
          0
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:36:10.472940",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize an empty dictionary to store numbers we have seen\n    dict = {}\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement with respect to the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in dict:\n            # Return the indices of the two numbers\n            return [dict[complement], i]\n        \n        # Add the current number as a key and its index as the value to the dictionary\n        dict[num] = i\n    \n    # Return an empty list if no such pair exists\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([-1, -2, 3, 4, 5], 6))  # Output: [1, 2]\nprint(two_sum([1, 3, 5, 7, 9], 11))  # Output: []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in dict:\n            return [dict[complement], i]\n        dict[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:36:22.727606",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:36:26.352676",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a dictionary to store the numbers and their indices\n    num_indices = {}\n    \n    # Iterate through the array\n    for index, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_indices:\n            # Return the indices as a list\n            return [num_indices[complement], index]\n        \n        # If not, add the current number and its index to the dictionary\n        num_indices[num] = index\n    \n    # Return an empty list if no pair is found\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    num_indices = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], index]\n        num_indices[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:36:35.704188",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize pointers\n    left, right = 0, len(nums) - 1\n    \n    # Iterate through the array using a while loop\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        # If the sum equals the target, return the indices\n        if current_sum == target:\n            return [left, right]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    # If no such pair is found, return an empty list or raise an exception\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([4, 6, 8, 10], 12))  # Output: [1, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:36:48.748493",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: list[int], target: int) -> list[int]:\n        seen = {}\n        for i in range(len(nums)):\n            if target - nums[i] in seen:\n                return [seen[target - nums[i]], i]\n            seen[nums[i]] = i",
    "code": "def two_sum(self, nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i in range(len(nums)):\n        if target - nums[i] in seen:\n            return [seen[target - nums[i]], i]\n        seen[nums[i]] = i\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:36:53.304429",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            for j in range(i+1,len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]",
    "code": "def two_sum(self, nums, target):\n    \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:36:54.879444",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    # If no solution is found, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:37:10.082049",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            left = i + 1\n            right = len(nums) - 1\n\n            while left < right:\n                current_sum = nums[i] + nums[right]\n                if current_sum == target:\n                    return [i, right]\n                elif current_sum < target:\n                    left += 1\n                else:\n                    right -= 1",
    "code": "def two_sum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[right]\n            if current_sum == target:\n                return [i, right]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:37:21.211711",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize pointers\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        # Calculate sum of elements at current pointers\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]  # Return indices of the two numbers\n        \n        elif current_sum > target:\n            right -= 1  # Move left pointer to the right\n        else:\n            left += 1  # Move right pointer to the left\n    \n    return []  # If no such pair is found\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([4, 6, 7, 8], 13))  # Output: [0, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:37:31.899474",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    :param nums: List of integers\n    :param target: Integer\n    :return: List of two integers whose sum equals target\n    \"\"\"\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen[complement], i]\n        seen[nums[i]] = i",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    :param nums: List of integers\n    :param target: Integer\n    :return: List of two integers whose sum equals target\n    \"\"\"\n    seen = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen:\n            return [seen[complement], i]\n        seen[nums[i]] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:37:34.189678",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'j' is not defined",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    seen_numbers = set()\n\n    for i in range(len(nums)):\n        complement = nums[i] + target - nums[j]\n        \n        # Check if the complement exists in the set\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # Add the current index to the set\n        seen_numbers.add(nums[i])\n\n    return result\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    seen_numbers = set()\n    for i in range(len(nums)):\n        complement = nums[i] + target - nums[j]\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers.add(nums[i])\n    return result",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:37:47.070863",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Check if the input list is empty or has fewer than 2 elements\n    if len(nums) < 2:\n        raise ValueError(\"The array must contain at least two elements.\")\n\n    # Initialize two pointers, one starting from the beginning and the other from the end of the array\n    left, right = 0, len(nums) - 1\n\n    # Iterate until the two pointers meet in the middle\n    while left < right:\n        current_sum = nums[left] + nums[right]\n\n        # If the sum is equal to the target, return the indices of the two numbers\n        if current_sum == target:\n            return [left, right]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n\n    # If no such pair is found, return None or handle the situation as needed\n    return None",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    if len(nums) < 2:\n        raise ValueError('The array must contain at least two elements.')\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:37:58.643428",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "name 'two_sum' is not defined",
    "raw_code": "res = []",
    "code": "",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:38:05.482523",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'defaultdict' is not defined",
    "raw_code": "from collections import defaultdict\n\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    seen = defaultdict(int)\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the hash set\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # If not, add the current number and its index to the hash set\n        seen[num] = i\n    \n    # Return an empty list if no solution is found\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = defaultdict(int)\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:38:14.262695",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a set to store seen numbers for O(1) average time complexity lookups\n    seen = set()\n    \n    # Iterate through each number in the array\n    for num in nums:\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the set of seen numbers\n        if complement in seen:\n            return [seen.index(complement), nums.index(num)]\n        \n        # Add the current number to the set of seen numbers\n        seen.add(num)\n    \n    # If no such pair is found, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), nums.index(num)]\n        seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:38:22.313787",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list, target: int) -> list:\n    # Create a dictionary to store the complements of the target\n    complements = {}\n    \n    for num in nums:\n        complement = target - num  # Calculate the complement needed to reach the target\n        if complement in complements:\n            return [complements[complement], num]  # Return the pair that sums up to the target\n        else:\n            complements[num] = num  # Add the current number to the dictionary with its complement\n    \n    # If no solution is found, return an empty list\n    return []",
    "code": "def two_sum(nums: list, target: int) -> list:\n    complements = {}\n    for num in nums:\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], num]\n        else:\n            complements[num] = num\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:38:24.711475",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(numbers, target):\n    # Create an empty list called result\n    result = []\n    # Iterate through each number in the numbers array\n    for i in range(len(numbers)):\n        # Calculate the complement needed by subtracting the current number from the target\n        complement = target - numbers[i]\n        # Check if the complement exists in the numbers array\n        if complement in numbers:\n            # If found, add the pair [current number and its complement] to the result list\n            result.append([numbers[i], complement])\n    return result",
    "code": "def two_sum(numbers, target):\n    result = []\n    for i in range(len(numbers)):\n        complement = target - numbers[i]\n        if complement in numbers:\n            result.append([numbers[i], complement])\n    return result",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          [
            2,
            7
          ],
          [
            7,
            2
          ]
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:38:30.210040",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'complement'",
    "raw_code": "def two_sum(nums: list, target: int) -> List[int]:\n    # Create a set to store numbers we have seen so far\n    seen = set()\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Calculate the complement that would add up to the target with the current number\n        complement = target - num\n        \n        # Check if the complement has already been seen\n        if complement in seen:\n            return [seen.complement(num), num]\n        \n        # Add the current number to the set of seen numbers\n        seen.add(num)\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test cases to verify the correctness of the solution\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list, target: int) -> List[int]:\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen.complement(num), num]\n        seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:38:36.723584",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    nums.sort()  # Sort the array to make it easier to use two-pointer technique\n    result = []\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            result.append(left)\n            result.append(right)\n            break\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    return result",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    result = []\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            result.append(left)\n            result.append(right)\n            break\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return result",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:38:38.862780",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate through each element in the input list\n    for i in range(len(nums)):\n        # Calculate the complement of the target number minus the current element\n        complement = target - nums[i]\n        \n        # Check if this complement exists in the list (i.e., if there's a pair that sums to the target)\n        if complement in nums:\n            # If found, add the pair [current_element, complement] to the result list\n            result.append([nums[i], complement])\n    \n    return result",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums:\n            result.append([nums[i], complement])\n    return result",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          [
            2,
            7
          ],
          [
            7,
            2
          ]
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:38:43.478310",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given a list of unique integers 'nums' and an integer 'target',\n    return a list containing the pair of numbers from the list that add up to 'target'.\n    \n    Args:\n    nums: List[int] - A list of unique integers.\n    target: int -> The integer sum to find in the list.\n    \n    Returns:\n    list[int] - A list containing the pair of numbers from the list that add up to 'target'.\n    \"\"\"\n    # Create a dictionary to store the number and its index\n    num_dict = {}\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        \n        # If not, add the number and its index to the dictionary\n        num_dict[num] = i\n\n# Test the function with provided data points\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given a list of unique integers 'nums' and an integer 'target',\n    return a list containing the pair of numbers from the list that add up to 'target'.\n    \n    Args:\n    nums: List[int] - A list of unique integers.\n    target: int -> The integer sum to find in the list.\n    \n    Returns:\n    list[int] - A list containing the pair of numbers from the list that add up to 'target'.\n    \"\"\"\n    num_dict = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[num] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:38:53.410962",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create a dictionary to store the numbers and their indices\n    nums_dict = {}\n    \n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums_dict:\n            return [nums_dict[complement], i]\n        else:\n            nums_dict[nums[i]] = i",
    "code": "def two_sum(nums, target):\n    nums_dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums_dict:\n            return [nums_dict[complement], i]\n        else:\n            nums_dict[nums[i]] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:38:56.433558",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "# Importing the necessary library for the solution\nfrom typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    # Using a dictionary to store the elements and their indices\n    seen = {}\n    \n    # Loop through each element in the array\n    for index, value in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - value\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], index]\n        \n        # If not, add the current element and its index to the dictionary\n        seen[value] = index\n    \n    # Return an empty list if no solution is found (this should never happen)\n    return []\n\n# Test cases to verify the correctness of the solution\nassert two_sum([2,7,11,15], 9) == [0,1]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen = {}\n    for index, value in enumerate(nums):\n        complement = target - value\n        if complement in seen:\n            return [seen[complement], index]\n        seen[value] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:39:03.020776",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "# Define a function that takes in a list of numbers `nums` and a target number `target`.\ndef two_sum(nums, target):\n    # Iterate through each number in the list.\n    for i in range(len(nums)):\n        # Calculate the complement of the current number with respect to the target.\n        complement = target - nums[i]\n        # Check if this complement exists in the list and is not the same as the current number.\n        if complement in nums[i+1:]:\n            return [i, nums[i+1:].index(complement)]\n    # If no such pair of numbers is found, return an empty list.\n    return []\n\n# Test cases to verify that the function works correctly.\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nprint(\"Test case 1 passed.\")\n\nassert two_sum([-3, 4, 6, 10], 9) == [2, 8]\nprint(\"Test case 2 passed.\")\n\nassert two_sum([1, 2, 3, 7], 5) == []\nprint(\"Test case 3 passed.\")",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums[i + 1:]:\n            return [i, nums[i + 1:].index(complement)]\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          0
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:39:10.077417",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the array to make it easier to use two pointers\n    nums.sort()\n    \n    # Initialize two pointers\n    left = 0\n    right = len(nums) - 1\n    \n    # Iterate through the sorted array\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            # Move the left pointer to increase the sum\n            left += 1\n        else:\n            # Move the right pointer to decrease the sum\n            right -= 1\n    \n    # If no pair is found, return None or handle as per requirements\n    return None\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [nums[left], nums[right]]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:39:23.441671",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given a list of numbers 'nums' and a target sum 'target', returns the indices of the two numbers that add up to 'target'.\n\n    :param nums: List[int] - A list of integers.\n    :param target: int - The target sum for which to find the two numbers.\n    :return: List[int] - The indices of the two numbers that add up to 'target'.\n    \"\"\"\n    # Create a set to keep track of seen numbers\n    seen = set()\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if this complement has already been seen\n        if complement in seen:\n            return [seen.index(complement), i]\n        \n        # Add the current number to the set of seen numbers\n        seen.add(num)\n    \n    # If no such pair is found, raise a ValueError\n    raise ValueError(\"No two numbers add up to the target\")\n\n# Test cases to verify the correctness of the function\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nprint(\"Test case 1 passed.\")\n\nassert two_sum([-1, 3, -4, 1], 0) == [-1, 3]\nprint(\"Test case 2 passed.\")\n\nassert two_sum([2, 3, 7, 11], 9) == [0, 1]\nprint(\"Test case 3 passed.\")\n\nassert two_sum([-1, 4, 3, 2, -5, 6, 8], 12) == [1, 4]\nprint(\"Test case 4 passed.\")",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given a list of numbers 'nums' and a target sum 'target', returns the indices of the two numbers that add up to 'target'.\n\n    :param nums: List[int] - A list of integers.\n    :param target: int - The target sum for which to find the two numbers.\n    :return: List[int] - The indices of the two numbers that add up to 'target'.\n    \"\"\"\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    raise ValueError('No two numbers add up to the target')",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:39:32.343174",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'target', find all unique pairs that add up to 'target'.\n    \n    Args:\n    nums (list[int]): The list of integers.\n    target (int): The target sum for the pairs.\n    \n    Returns:\n    list[int]: A list of unique pairs that add up to 'target'.\n    \n    Example:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            result.append((complement, num))\n        seen.add(num)\n    return result\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given a list of integers 'nums' and an integer 'target', find all unique pairs that add up to 'target'.\n    \n    Args:\n    nums (list[int]): The list of integers.\n    target (int): The target sum for the pairs.\n    \n    Returns:\n    list[int]: A list of unique pairs that add up to 'target'.\n    \n    Example:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    \"\"\"\n    seen = set()\n    result = []\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            result.append((complement, num))\n        seen.add(num)\n    return result",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          [
            2,
            7
          ]
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:39:54.672054",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize pointers\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        # Calculate the sum of the elements at the two pointers\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            # Return the indices of the two elements\n            return [left, right]\n        \n        elif current_sum > target:\n            # Move the right pointer to the left (decrease the sum)\n            right -= 1\n        else:\n            # Move the left pointer to the right (increase the sum)\n            left += 1\n    \n    # If no solution is found, return an empty list\n    return []\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:40:11.668395",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize an empty dictionary to store elements as keys and their indices as values\n    memo = {}\n    \n    # Iterate through each element in the list\n    for i in range(len(nums)):\n        # Calculate the complement of the current element with respect to the target\n        complement = target - nums[i]\n        \n        # Check if the complement is already in the dictionary\n        if complement in memo:\n            # Return the indices of the two elements that add up to the target\n            return [memo[complement], i]\n        \n        # Otherwise, store the current element as a key with its index in the dictionary\n        memo[nums[i]] = i\n    \n    # If no solution is found, return an empty list\n    return []\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    memo = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in memo:\n            return [memo[complement], i]\n        memo[nums[i]] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:40:19.689404",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create an empty dictionary to store the numbers and their indices\n    lookup = {}\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement of the target number with respect to the current number\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in lookup:\n            # Return the indices of the two numbers that add up to the target\n            return [lookup[complement], i]\n        \n        # Otherwise, add the current number and its index to the dictionary\n        lookup[num] = i\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    lookup = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in lookup:\n            return [lookup[complement], i]\n        lookup[num] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:40:25.346558",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'complement'",
    "raw_code": "def two_sum(nums, target):\n    seen_numbers = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers.complement(num), num]\n        else:\n            seen_numbers.add(num)\n    return None\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    seen_numbers = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers.complement(num), num]\n        else:\n            seen_numbers.add(num)\n    return None",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:40:31.949033",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object is not subscriptable",
    "raw_code": "def two_sum(nums, target):\n    # Initialize an empty set to store unique elements from the list\n    seen = set()\n    \n    # Iterate over each number in the list\n    for num in nums:\n        # Calculate the complement needed to reach the target value\n        complement = target - num\n        \n        # Check if the complement is already in the set\n        if complement in seen:\n            return [seen[complement], num]\n        \n        # If not, add the current number to the set\n        seen.add(num)\n    \n    # Return an empty list if no such pair is found\n    return []\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], num]\n        seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:40:40.250162",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a set to store seen numbers\n    seen = set()\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if the complement is already in the set\n        if complement in seen:\n            return [seen.index(complement), i]\n        \n        # Add the current number to the set\n        seen.add(num)\n    \n    # If no two numbers sum up to the target, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T15:40:47.648323",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given a list of integers nums and an integer target,\n    return a list of indices where the two numbers sum up to the target.\n    \n    :param nums: List of integers\n    :param target: Target value\n    :return: A list containing the indices of the two numbers that sum to target\n    \"\"\"\n    # Create an empty dictionary to store the complement of each number from the input list\n    complements = {}\n    \n    # Iterate through each number in the input list\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in complements:\n            return [complements[complement], i]\n        \n        # Otherwise, add the current number as a key with its index to the dictionary\n        complements[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test cases to verify the correctness of the function\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given a list of integers nums and an integer target,\n    return a list of indices where the two numbers sum up to the target.\n    \n    :param nums: List of integers\n    :param target: Target value\n    :return: A list containing the indices of the two numbers that sum to target\n    \"\"\"\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:41:05.006439",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of unique integers nums and a target integer,\n    return all pairs of numbers that add up to the target.\n    \n    :param nums: List[int] - The input array of unique integers.\n    :param target: int - The target integer.\n    :return: List[List[int]] - A list containing all pairs of numbers from the input array that sum up to the target.\n    \"\"\"\n    seen = {}\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], num]\n        else:\n            seen[num] = num\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of unique integers nums and a target integer,\n    return all pairs of numbers that add up to the target.\n    \n    :param nums: List[int] - The input array of unique integers.\n    :param target: int - The target integer.\n    :return: List[List[int]] - A list containing all pairs of numbers from the input array that sum up to the target.\n    \"\"\"\n    seen = {}\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], num]\n        else:\n            seen[num] = num",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:41:12.570934",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "# Define the function to find pairs that add up to a given target value\ndef two_sum(nums, target):\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate over each number in the input array\n    for i in range(len(nums)):\n        # Calculate the complement needed to reach the target\n        complement = target - nums[i]\n        \n        # Check if the complement exists in the remaining elements of the array\n        if complement in nums[i + 1:]:\n            # If it does, add the indices of these two numbers to the result list\n            result.append([i, nums[i + 1:].index(complement)])\n    \n    return result\n\n# Test the function with provided data points\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    result = []\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in nums[i + 1:]:\n            result.append([i, nums[i + 1:].index(complement)])\n    return result",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          [
            0,
            0
          ]
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T15:41:20.242043",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the list to use the two-pointer technique\n    nums.sort()\n    \n    # Initialize pointers\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]  # Return indices of the two numbers\n        elif current_sum < target:\n            left += 1  # Move left pointer to the right to increase sum\n        else:\n            right -= 1  # Move right pointer to the left to decrease sum\n    \n    return None  # If no solution is found\n\n# Test cases\nassert two_sum([2,7,11,15], 9) == [0, 1]\nprint(two_sum([3,2,4,6,7], 9))  # Output: [1, 2]\nprint(two_sum([-1,0,1,2,3,4], 0))  # Output: [2, 3]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:36:19.361619",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers `nums` and an integer `target`,\n    return the indices of the two numbers such that they add up to `target`.\n    \n    :param nums: List[int] - The list of integers.\n    :param target: int - The target sum to find in the list.\n    :return: A list containing the indices of the two numbers that add up to `target`.\n    \"\"\"\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers `nums` and an integer `target`,\n    return the indices of the two numbers such that they add up to `target`.\n    \n    :param nums: List[int] - The list of integers.\n    :param target: int - The target sum to find in the list.\n    :return: A list containing the indices of the two numbers that add up to `target`.\n    \"\"\"\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:36:24.810271",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums: List[int] - A list of integers.\n    - target: int - The integer value whose sum we're looking for.\n    \n    Returns:\n    - Tuple[int]: A tuple containing the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    # Create a dictionary to store the number and its index\n    num_to_index = {}\n    \n    # Iterate over each number in the list\n    for i, num in enumerate(nums):\n        complement = target - num\n        \n        # If the complement is already in the dictionary, return their indices\n        if complement in num_to_index:\n            return (num_to_index[complement], i)\n        \n        # Store the current number and its index in the dictionary\n        num_to_index[num] = i\n    \n    # Return None if no such pair is found\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: (0, 2)",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums: List[int] - A list of integers.\n    - target: int - The integer value whose sum we're looking for.\n    \n    Returns:\n    - Tuple[int]: A tuple containing the indices of the two numbers in nums that add up to target.\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return (num_to_index[complement], i)\n        num_to_index[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:36:34.496930",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Find the indices of two distinct elements in a given list 'nums' that add up to 'target'.\n    \n    Parameters:\n        nums (list): The input list of integers.\n        target (int): The target sum to find within the list.\n        \n    Returns:\n        tuple: A tuple containing the indices of the two numbers that add up to the target, or None if no such pair exists.\n        \n    Examples:\n    >>> two_sum([1, 2, 3, 4], 5)\n    (0, 2)\n    >>> two_sum([-1, -3, 2, 1], 2)\n    (1, 2)\n    \"\"\"\n    seen = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return (seen[complement], index)\n        seen[num] = index\n\n# Test the function with provided data points\nassert two_sum([1, 2, 3, 4], 5) == (0, 2)\nassert two_sum([-1, -3, 2, 1], 2) == (1, 2)\nprint(\"All tests passed successfully.\")",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Find the indices of two distinct elements in a given list 'nums' that add up to 'target'.\n    \n    Parameters:\n        nums (list): The input list of integers.\n        target (int): The target sum to find within the list.\n        \n    Returns:\n        tuple: A tuple containing the indices of the two numbers that add up to the target, or None if no such pair exists.\n        \n    Examples:\n    >>> two_sum([1, 2, 3, 4], 5)\n    (0, 2)\n    >>> two_sum([-1, -3, 2, 1], 2)\n    (1, 2)\n    \"\"\"\n    seen = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return (seen[complement], index)\n        seen[num] = index",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:36:41.001240",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers\n    such that they add up to target.\n    \n    :param nums: List[int] - A list of integers.\n    :param target: int - The target sum.\n    :return: List[int] - Indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        if num in seen_numbers:\n            return [seen_numbers[num], i]\n        seen_numbers[target-num] = i\n    return []\n\n# Example check function to verify the solution\ndef check_solution():\n    assert two_sum([1, 2, 3, 4, 5], 9) == [0, 1], \"Test case 1 failed\"\n    assert two_sum([10, 20, -10, 5], -50) == [0, 3], \"Test case 2 failed\"\n    assert two_sum([7, 6, 4, 3], 15) == [0, 3], \"Test case 3 failed\"\n    print(\"All test cases passed!\")\n\ncheck_solution()",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers\n    such that they add up to target.\n    \n    :param nums: List[int] - A list of integers.\n    :param target: int - The target sum.\n    :return: List[int] - Indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        if num in seen_numbers:\n            return [seen_numbers[num], i]\n        seen_numbers[target - num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:36:47.309775",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n\n    Args:\n        nums (List[int]): The list of integers.\n        target (int): The target sum to find.\n\n    Returns:\n        List[int]: A list containing the indices of the two numbers that add up to target. If no such pair exists, returns an empty list.\n    \"\"\"\n    # Dictionary to store the complements of the target value\n    num_map = {}\n\n    for index, num in enumerate(nums):\n        complement = target - num\n\n        if complement in num_map:\n            return [num_map[complement], index]\n        \n        num_map[num] = index\n\n    # If no pair is found, return an empty list\n    return []\n\n# Example usage\nnums = [3, 1, 2, 4]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 3]\n\nnums = [-1, -2, 3, 7]\ntarget = 5\nprint(two_sum(nums, target))  # Output: [1, 4]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Returns the indices of the two numbers in nums that add up to target.\n\n    Args:\n        nums (List[int]): The list of integers.\n        target (int): The target sum to find.\n\n    Returns:\n        List[int]: A list containing the indices of the two numbers that add up to target. If no such pair exists, returns an empty list.\n    \"\"\"\n    num_map = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], index]\n        num_map[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:36:56.260524",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums (list[int]): The array of integers to search through.\n    - target (int): The target sum to find in the array.\n    \n    Returns:\n    - list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    # Create a dictionary to store the numbers we've seen so far\n    seen_numbers = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n    \n        # Check if the complement exists in the dictionary\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # Add the current number to the dictionary with its index\n        seen_numbers[num] = i\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test cases\nnums1 = [2, 7, 11, 15]\ntarget1 = 9\nprint(two_sum(nums1, target1))  # Output: [0, 1]\n\nnums2 = [-1, 0, 1, 4, -3]\ntarget2 = 6\nprint(two_sum(nums2, target2))  # Output: [1, 4]\n\nnums3 = []\ntarget3 = 7\nprint(two_sum(nums3, target3))  # Output: []\n\nnums4 = [10, -5, 8, 9]\ntarget4 = 6\nprint(two_sum(nums4, target4))  # Output: [2, 5]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums (list[int]): The array of integers to search through.\n    - target (int): The target sum to find in the array.\n    \n    Returns:\n    - list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:06.737682",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    d = {}\n    for i in range(len(nums)):\n        # Check if the complement of the current number is already in the dictionary\n        if (target - nums[i]) in d:\n            return [d[target - nums[i]], i]\n        else:\n            # Add the current number to the dictionary with its index\n            d[nums[i]] = i\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([1, 3, 4, 2], 6))  # Output: [1, 2]\nprint(two_sum([-1, -2, -3, 7], 2))  # Output: [0, 3]\nprint(two_sum([], 5))           # Output: []",
    "code": "def two_sum(nums, target):\n    d = {}\n    for i in range(len(nums)):\n        if target - nums[i] in d:\n            return [d[target - nums[i]], i]\n        else:\n            d[nums[i]] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:11.749416",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n    \n    :param nums: The list of integers.\n    :param target: The target sum.\n    :return: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1], \"Test case 1 failed\"\nassert two_sum([3, 2, 4, 6, 7], 9) == [1, 2], \"Test case 2 failed\"\nprint(\"All test cases passed!\")",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers such that they add up to target.\n    \n    :param nums: The list of integers.\n    :param target: The target sum.\n    :return: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:18.075927",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create a dictionary to store the complement of each number as a key,\n    # and its corresponding index in the array as the value.\n    complements = {}\n\n    # Iterate through each number in the input array.\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target.\n        complement = target - num\n\n        # Check if this complement exists in the dictionary.\n        if complement in complements:\n            return [complements[complement], i]\n\n        # Add the current number and its index to the dictionary.\n        complements[num] = i\n\n    # If no two numbers sum up to the target, return an empty list.\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([-1, 0, 1, -4], 1))   # Output: [3, 4]\nprint(two_sum([]))                # Output: []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    complements = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], i]\n        complements[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:24.531587",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> Optional[int]:\n    # Use two pointers to find the two numbers that add up to the target\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum < target:\n            # Move the left pointer to the right to increase the sum\n            left += 1\n        else:\n            # Move the right pointer to the left to decrease the sum\n            right -= 1\n    \n    # Return None if no such pair is found\n    return None\n\n# Example usage:\nnums = [2, 4, 7, 11]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 2]",
    "code": "def two_sum(nums: List[int], target: int) -> Optional[int]:\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:35.173517",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    n = len(nums)\n    \n    # Iterate through each number in the array\n    for i in range(n):\n        # Check if there exists another number that, when added to nums[i], equals the target\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    \n    # If no pair is found, return -1\n    return -1\n\n# Example usage:\nnums = [2, 7, 8, 10]\ntarget = 14\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 3]",
    "code": "def two_sum(nums, target):\n    n = len(nums)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return -1",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:44.172463",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create an empty dictionary to store numbers and their indices\n    num_index = {}\n    \n    # Iterate over each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in num_index:\n            return [num_index[complement], i]\n        \n        # If not found, add the number and its index to the dictionary\n        num_index[num] = i\n    \n    # If no two numbers sum up to the target, return None\n    return None\n\n# Test cases\nnums1 = [2, 7, 11, 15]\ntarget1 = 9\nprint(two_sum(nums1, target1))  # Output: [0, 1]\n\nnums2 = [3, 4, -3, 6, 8]\ntarget2 = 9\nprint(two_sum(nums2, target2))  # Output: [1, 2]\n\nnums3 = [5, 5, 5]\ntarget3 = 10\nprint(two_sum(nums3, target3))  # Output: None\n\nnums4 = []\ntarget4 = 7\nprint(two_sum(nums4, target4))  # Output: None",
    "code": "def two_sum(nums, target):\n    num_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_index:\n            return [num_index[complement], i]\n        num_index[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:37:54.884573",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty dictionary to store numbers and their indices\n    num_indices = {}\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        \n        # If not, add the number and its index to the dictionary\n        num_indices[num] = i\n    \n    # If no such pair is found, return None or raise an exception\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nif result:\n    print(f\"The indices of the two numbers are: {result}\")\nelse:\n    print(\"No such pair found.\")",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        num_indices[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:38:04.307656",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    \n    return []\n\n# Example usage:\nnums = [2, 7, 8, 9, 11]\ntarget = 13\nprint(two_sum(nums, target))  # Output: [1, 4] because nums[1] + nums[4] equals 13\n\nnums = [1, 5, 9, 11]\ntarget = 16\nprint(two_sum(nums, target))  # Output: [0, 2] because nums[0] + nums[2] equals 16\n\nnums = [1, 2, 3, 4, 5]\ntarget = 8\nprint(two_sum(nums, target))  # Output: [0, 3] because nums[0] + nums[3] equals 8\n\nnums = [10, 15, 7, 18, 20]\ntarget = 49\nprint(two_sum(nums, target))  # Output: [2, 2] because nums[2] + nums[2] equals 49",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:38:18.384854",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find the indices of two numbers in the array that add up to the target.\n\n    :param nums: List of integers.\n    :param target: Integer representing the target sum.\n    :return: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    n = len(nums)\n    left, right = 0, n - 1\n\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\n# Test Cases\nprint(two_sum([3, 2, 4, 7], 9))  # Output: [0, 2]\nprint(two_sum([1, 2, 4, 5], 5))   # Output: [1, 4]\nprint(two_sum([2, 4, 6, 8], 10)) # Output: [2, 4]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Find the indices of two numbers in the array that add up to the target.\n\n    :param nums: List of integers.\n    :param target: Integer representing the target sum.\n    :return: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    n = len(nums)\n    left, right = (0, n - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:38:28.458916",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            s = nums[i] + nums[left]\n            if s == target:\n                return [i, left]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            s = nums[i] + nums[left]\n            if s == target:\n                return [i, left]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:38:35.643293",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution(object):\n    def two_sum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        # Initialize an empty dictionary to store numbers and their indices\n        num_to_index = {}\n        \n        # Iterate through each number in the array\n        for index, value in enumerate(nums):\n            # Calculate the complement needed to reach the target sum\n            complement = target - value\n            \n            # Check if the complement is already in the dictionary\n            if complement in num_to_index:\n                return [num_to_index[complement], index]\n            \n            # If not, add the current number and its index to the dictionary\n            num_to_index[value] = index\n        \n        # If no solution is found, return None or raise an error based on your requirements\n        return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(self, nums, target):\n    \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n    num_to_index = {}\n    for index, value in enumerate(nums):\n        complement = target - value\n        if complement in num_to_index:\n            return [num_to_index[complement], index]\n        num_to_index[value] = index\n    return None\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:38:41.996207",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a set to store the numbers we have seen so far\n    seen = set()\n    \n    # Iterate through each number in the list\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the set\n        if complement in seen:\n            return [seen.index(complement), i]\n        \n        # Add the current number to the set\n        seen.add(num)\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([1, 3, 5, 0], -1))   # Output: [0, 3]\nprint(two_sum([-1, 1, 2, 4], 2))   # Output: [0, 2]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen = set()\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen.index(complement), i]\n        seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:38:53.375102",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "list index out of range",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a set to store numbers we have seen so far\n    seen = set()\n    \n    for left, right in enumerate(nums):\n        complement = target - nums[right]\n        \n        # Check if the complement exists in the set\n        if complement in seen:\n            return [seen.index(complement), right]\n        \n        # Add the current number to the set of seen numbers\n        seen.add(nums[right])\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 2]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen = set()\n    for left, right in enumerate(nums):\n        complement = target - nums[right]\n        if complement in seen:\n            return [seen.index(complement), right]\n        seen.add(nums[right])\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:39:01.521035",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize pointers for the left and right sides of the array\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]  # Return indices of the two numbers\n        elif current_sum < target:\n            left += 1  # Move left pointer to the right to increase sum\n        else:\n            right -= 1  # Move right pointer to the left to decrease sum\n    \n    return -1  # If no such pair is found, return -1\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 2]",
    "code": "def two_sum(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return -1",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:39:12.780625",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen_numbers = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # Add the current number and its index to the dictionary\n        seen_numbers[num] = i\n    \n    # If no two numbers add up to the target, return None\n    return None\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 3]\nprint(two_sum([1, 3, 4, 6, 9], 10)) # Output: [1, 2]\nprint(two_sum([-1, 1, -5, 4, 2], 2))  # Output: [1, 4]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen_numbers = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[num] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:39:25.085981",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Return the indices of the two numbers in the array that add up to the target.\n\n    Parameters:\n    nums (list[int]): The list of integers.\n    target (int): The target sum to find.\n\n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Return the indices of the two numbers in the array that add up to the target.\n\n    Parameters:\n    nums (list[int]): The list of integers.\n    target (int): The target sum to find.\n\n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:39:32.545323",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty dictionary to store elements as keys and their indices as values\n    seen = {}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n    \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], i]\n        \n        # Add the current element to the dictionary with its index\n        seen[num] = i\n    \n    # If no such pair is found, return an empty list or handle it as needed\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15, 8]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:39:40.845153",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty dictionary to store numbers and their indices\n    num_indices = {}\n    \n    # Iterate over each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if the complement exists in the hash set\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        num_indices[num] = i\n    \n    # If no two numbers add up to the target, return an empty list\n    return []\n\n# Test cases\nprint(two_sum([1, 2, 3, 4], 7))  # Output: [0, 3]\nprint(two_sum([1, 5, 9, 14], 13))  # Output: [0, 3]\nprint(two_sum([-1, -3, -2], -5))  # Output: [0, 2]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    num_indices = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_indices:\n            return [num_indices[complement], i]\n        num_indices[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:39:49.957081",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Dictionary to store the numbers we've seen so far\n    seen_numbers = {}\n    \n    # Iterate through each number in the array\n    for i in range(len(nums)):\n        # Calculate the complement that we need to find\n        complement = target - nums[i]\n        \n        # Check if this complement is already in our dictionary\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        \n        # If not, add the current number and its index to our dictionary\n        seen_numbers[nums[i]] = i\n    \n    # Return None if no solution is found\n    return None\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    seen_numbers = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in seen_numbers:\n            return [seen_numbers[complement], i]\n        seen_numbers[nums[i]] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:39:56.352466",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Initialize pointers at the start and end of the array\n    left, right = 0, len(nums) - 1\n    \n    # Iterate until the two pointers meet in the middle\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]  # Return indices of the two numbers\n        \n        elif current_sum < target:\n            left += 1  # Move the pointer to the right\n        else:\n            right -= 1  # Move the pointer to the left\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:40:05.914797",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Natural language",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize an empty dictionary to store numbers we have seen\n    hash_map = {}\n    \n    # Iterate through each number in the array\n    for index, num in enumerate(nums):\n        # Calculate the complement of the current number\n        complement = target - num\n        \n        # Check if the complement exists in the dictionary\n        if complement in hash_map:\n            # Return the indices of these two numbers\n            return [hash_map[complement], index]\n        \n        # If not, add the current number and its index to the dictionary\n        hash_map[num] = index\n    \n    # Return an empty list if no solution is found\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 1]\nprint(two_sum([1, 3, 4, 5, 6], 8))   # Output: [0, 2]\nprint(two_sum([-1, -2, -3, -4, -5], -6))  # Output: [0, 1]\nprint(two_sum([1, 2, 3, 4, 5], 7))   # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    hash_map = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in hash_map:\n            return [hash_map[complement], index]\n        hash_map[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:40:18.774936",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        for i in range(len(nums)):\n            j = len(nums) - 1 - i\n            if nums[i] + nums[j] == target:\n                return [i, j]",
    "code": "def two_sum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        j = len(nums) - 1 - i\n        if nums[i] + nums[j] == target:\n            return [i, j]\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:40:21.072472",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers that add up to target.\n    \n    The function returns a list containing the indices of the two numbers in ascending order.\n    If no such pair exists, it returns an empty list.\n    \n    Example usage:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 2]\n    >>> two_sum([-3, 4, 6, -8], 8)\n    [1, 3]\n    \"\"\"\n    # Dictionary to store numbers and their indices\n    num_indices = {}\n    \n    for index, number in enumerate(nums):\n        complement = target - number\n    \n        # Check if the complement exists in the dictionary\n        if complement in num_indices:\n            return [num_indices[complement], index]\n        \n        # Store the current number and its index in the dictionary\n        num_indices[number] = index\n\n# Example usage\nprint(two_sum([2, 7, 11, 15], 9))  # Output: [0, 2]\nprint(two_sum([-3, 4, 6, -8], 8))    # Output: [1, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target,\n    return indices of the two numbers that add up to target.\n    \n    The function returns a list containing the indices of the two numbers in ascending order.\n    If no such pair exists, it returns an empty list.\n    \n    Example usage:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 2]\n    >>> two_sum([-3, 4, 6, -8], 8)\n    [1, 3]\n    \"\"\"\n    num_indices = {}\n    for index, number in enumerate(nums):\n        complement = target - number\n        if complement in num_indices:\n            return [num_indices[complement], index]\n        num_indices[number] = index",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:40:29.822072",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "from typing import List\n\n# Define the function for two sum\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find the indices of the two numbers in the given list that add up to the target.\n    \n    Parameters:\n    - nums (List[int]): The list of integers to search through.\n    - target (int): The integer whose sum with any element in the list should equal the target.\n    \n    Returns:\n    - List[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = set()\n    for index, number in enumerate(nums):\n        complement = target - number\n        if complement in seen_numbers:\n            return [seen_numbers.index(complement), index]\n        seen_numbers.add(number)\n    \n    # If no solution is found, return an empty list\n    return []\n\n# Test cases to verify the correctness of the function\nassert two_sum([1, 3, 5, 0], 9) == [0, 2]\nassert two_sum([1, 4, 7, 11], 15) == [0, 3]\nassert two_sum([-1, -2, -3, 4, 6], 8) == [0, 2, 6]\nassert two_sum([1], 2) == []",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    \"\"\"\n    Find the indices of the two numbers in the given list that add up to the target.\n    \n    Parameters:\n    - nums (List[int]): The list of integers to search through.\n    - target (int): The integer whose sum with any element in the list should equal the target.\n    \n    Returns:\n    - List[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = set()\n    for index, number in enumerate(nums):\n        complement = target - number\n        if complement in seen_numbers:\n            return [seen_numbers.index(complement), index]\n        seen_numbers.add(number)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:40:39.659947",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "name 'two_sum' is not defined",
    "raw_code": "return [i for i in range(len(nums)) if nums[i] + nums[nums.index(i)] == target]",
    "code": "",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:40:40.246057",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "from typing import List\n\ndef two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums (List[int]): The array of integers.\n    - target (int): The target sum.\n    \n    Returns:\n    - List[int]: A list containing the indices of the two numbers that add up to the target. If no such pair exists, returns an empty list.\n    \n    Example:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    \n    >>> two_sum([-1, 4, 5, 9, 13], 18)\n    [3, 5]\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], i]\n        seen[num] = i\n    return []\n\n# Explanation:\n# The function `two_sum` takes two parameters: a list of integers `nums` and an integer `target`.\n# It initializes an empty dictionary `seen` to keep track of the numbers that have been encountered.\n# Then, it iterates through each number in the list using its index `i`.\n# For each number, it checks if the complement (i.e., the target minus the current number) is already present in the `seen` dictionary.\n# If it is, the function returns a list containing the indices of the two numbers that add up to the target.\n# If no such pair exists, the function returns an empty list.",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Args:\n    - nums (List[int]): The array of integers.\n    - target (int): The target sum.\n    \n    Returns:\n    - List[int]: A list containing the indices of the two numbers that add up to the target. If no such pair exists, returns an empty list.\n    \n    Example:\n    >>> two_sum([2, 7, 11, 15], 9)\n    [0, 1]\n    \n    >>> two_sum([-1, 4, 5, 9, 13], 18)\n    [3, 5]\n    \"\"\"\n    seen = {}\n    for i, num in enumerate(nums):\n        if target - num in seen:\n            return [seen[target - num], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:40:48.509676",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "'set' object is not subscriptable",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Returns the indices of the two numbers in the array nums that add up to the target.\n    \n    Args:\n    nums (list[int]): The array of integers.\n    target (int): The target sum.\n    \n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = set()  # Set to keep track of seen numbers\n    result = []  # List to store the result\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the set\n        if complement in seen:\n            # If it is, return the current index and the complement's index\n            return [i, seen[complement]]\n        \n        # Add the current number to the set\n        seen.add(num)\n    \n    # If no solution is found, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Returns the indices of the two numbers in the array nums that add up to the target.\n    \n    Args:\n    nums (list[int]): The array of integers.\n    target (int): The target sum.\n    \n    Returns:\n    list[int]: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen = set()\n    result = []\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [i, seen[complement]]\n        seen.add(num)\n    return []",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:40:56.770288",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: List[int], target: int) -> List[int]:\n        # Initialize an empty list to store the indices of the two numbers\n        ans = []\n        \n        # Iterate through each number in the input array\n        for i in range(len(nums)):\n            # Check if the complement (target - current number) exists in the remaining elements\n            if target - nums[i] in nums[i+1:]:\n                # If found, append the indices of the two numbers to the answer list\n                ans.append(i)\n                ans.append(nums.index(target - nums[i], i + 1))\n                \n        return ans",
    "code": "def two_sum(self, nums: List[int], target: int) -> List[int]:\n    ans = []\n    for i in range(len(nums)):\n        if target - nums[i] in nums[i + 1:]:\n            ans.append(i)\n            ans.append(nums.index(target - nums[i], i + 1))\n    return ans\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:40:59.496699",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        Return indices of the two numbers such that they add up to target.\n        \n        Args:\n            - nums (list[int]): A list of integers.\n            - target (int): The target sum.\n            \n        Returns:\n            - List[int]: A list containing the two indices of the two numbers that sum up to the target.\n        \"\"\"\n        # Create a dictionary to store the values as keys and their corresponding indices as values\n        hash_map = {}\n        \n        for index, value in enumerate(nums):\n            complement = target - value\n            if complement in hash_map:\n                return [hash_map[complement], index]\n            else:\n                hash_map[value] = index",
    "code": "def two_sum(self, nums: List[int], target: int) -> List[int]:\n    \"\"\"\n        Return indices of the two numbers such that they add up to target.\n        \n        Args:\n            - nums (list[int]): A list of integers.\n            - target (int): The target sum.\n            \n        Returns:\n            - List[int]: A list containing the two indices of the two numbers that sum up to the target.\n        \"\"\"\n    hash_map = {}\n    for index, value in enumerate(nums):\n        complement = target - value\n        if complement in hash_map:\n            return [hash_map[complement], index]\n        else:\n            hash_map[value] = index\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:41:07.896624",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Constraints:\n        Each input has exactly one solution. Do not use the same element twice.\n        \n    Examples:\n        Input: nums = [2, 7, 11, 15], target = 9 \u2192 Output: [0, 1]\n    Function name: two_sum\n    \"\"\"\n    # Create a dictionary to store numbers and their indices\n    num_to_index = {}\n    \n    # Iterate through the array using enumerate to get both the index and value of each element\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if this complement is already in the dictionary\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        num_to_index[num] = i\n    \n    # If no solution is found, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n    \n    Constraints:\n        Each input has exactly one solution. Do not use the same element twice.\n        \n    Examples:\n        Input: nums = [2, 7, 11, 15], target = 9 \u2192 Output: [0, 1]\n    Function name: two_sum\n    \"\"\"\n    num_to_index = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement], i]\n        num_to_index[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:41:15.910375",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Dictionary to store seen numbers\n    dic = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement with respect to the current element\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in dic:\n            return [dic[complement], i]\n        \n        # Add the current number to the dictionary\n        dic[num] = i\n    \n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 3]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    dic = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in dic:\n            return [dic[complement], i]\n        dic[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:41:26.986392",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Dictionary to store numbers and their indices\n    seen = {}\n    \n    # Iterate through each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            # Return the indices of the two numbers\n            return [seen[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        seen[num] = i\n    \n    # If no two numbers sum up to the target, return an empty list or raise an error\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:41:35.823492",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test the function with provided data points\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 3]\n\nnums = [1, 3, 4, 6]\ntarget = 7\nprint(two_sum(nums, target))  # Output: [1, 2]\n\nnums = [-1, -2, -3, -4]\ntarget = 0\nprint(two_sum(nums, target))  # Output: []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:41:47.017999",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "name 'two_sum' is not defined",
    "raw_code": "# Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n# Example:\n# >>> two_sum([2, 7, 11], 9)\n# [0, 1]",
    "code": "",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:41:48.174949",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Sort the array\n    nums.sort()\n    \n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        complement = target - nums[left]\n        \n        if complement in nums[right:]:\n            return [left, right]\n        \n        # Move the pointer that points to the smaller element\n        if nums[left] < nums[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return []\n\n# Example usage:\nnums = [2, 7, 3, 8, 9]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 2] or [1, 4]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    nums.sort()\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        complement = target - nums[left]\n        if complement in nums[right:]:\n            return [left, right]\n        if nums[left] < nums[right]:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:42:00.936121",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Sort the array to use the two-pointer technique\n    nums.sort()\n    \n    # Initialize two pointers, one at the start and one at the end\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum < target:\n            left += 1  # Move the left pointer to the right\n        else:\n            right -= 1  # Move the right pointer to the left\n    \n    # If no such pair is found, return an empty list or a tuple with the index of that element\n    return []\n\n# Test cases\nprint(two_sum([2, 7, 11], 9))  # Output: [0, 1]\nprint(two_sum([4, 5, 6], 9))   # Output: [2, 3]\nprint(two_sum([-1, -2, -3], 0))  # Output: [-1, 1]\nprint(two_sum([], 0))         # Output: []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:42:16.694992",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'Solution' is not defined",
    "raw_code": "class Solution:\n    def two_sum(self, nums: list[int], target: int) -> list[int]:\n        left = 0\n        right = len(nums) - 1\n        \n        # Use a while loop to find the pair of numbers that sum up to the target\n        while left < right:\n            current_sum = nums[left] + nums[right]\n            \n            if current_sum == target:\n                # Found a pair, return their indices\n                return [left, right]\n            elif current_sum < target:\n                # If the sum is less than the target, move the left pointer to increase the sum\n                left += 1\n            else:\n                # If the sum is greater than the target, move the right pointer to decrease the sum\n                right -= 1\n        \n        # If no pair is found, return an empty list or raise an exception if needed\n        return []",
    "code": "def two_sum(self, nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\ndef two_sum(*args, **kwargs):\n    return Solution().two_sum(*args, **kwargs)\n",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:42:38.339857",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty dictionary to store numbers and their indices\n    seen_numbers = {}\n    \n    # Iterate through the array\n    for index, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen_numbers:\n            # If it is, return the indices of the two numbers\n            return [seen_numbers[complement], index]\n        \n        # Add the current number to the dictionary with its index\n        seen_numbers[num] = index\n    \n    # Return an empty list if no two numbers add up to the target\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen_numbers = {}\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers[complement], index]\n        seen_numbers[num] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:42:53.191021",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}  # Dictionary to store numbers and their indices\n\n    for i, num in enumerate(nums):\n        complement = target - num  # Calculate the complement needed to reach the target\n\n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], i]  # Return the index of the number and the complement\n\n        # Otherwise, add the current number to the dictionary with its index\n        seen[num] = i\n\n    return []  # If no two numbers sum up to the target, return an empty list\n\n# Test cases\nassert two_sum([1, 3, 5, 0], 9) == [2, 4]\nassert two_sum([1, 3, -2, 1], 0) == [1, 2]\nassert two_sum([-1, -2, 1], -1) == [0, 1]\nassert two_sum([7, 8, 9, 6], 15) == [4, 5]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:43:02.939475",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "'set' object is not subscriptable",
    "raw_code": "from typing import List\n\ndef two_sum(nums: List[int], target: int) -> List[int]:\n    seen = set()  # Use a set to store the numbers we have seen so far\n    for num in nums:\n        if target - num in seen:\n            return [seen[target-num], num]  # Return the pair of indices\n        seen.add(num)",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    seen = set()\n    for num in nums:\n        if target - num in seen:\n            return [seen[target - num], num]\n        seen.add(num)",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:43:25.466700",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    \n    # Iterate until the two pointers meet\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            # If the current sum equals the target, return the indices of the elements\n            return [left, right]\n        \n        # If the current sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the current sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    # If no solution is found, return an empty list\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:43:34.873000",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Docstring + signature",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize an empty dictionary to store numbers and their indices\n    seen = {}\n    \n    # Iterate over each number in the array\n    for i, num in enumerate(nums):\n        # Calculate the complement of the current number with respect to the target\n        complement = target - num\n        \n        # Check if this complement is already in the dictionary\n        if complement in seen:\n            # If it is, return the indices of these two numbers\n            return [seen[complement], i]\n        \n        # Otherwise, add the current number and its index to the dictionary\n        seen[num] = i\n    \n    # Return an empty list indicating no solution exists\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nprint(two_sum(nums, target))  # Output: [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:43:57.707784",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums,target):\n    for i in range(len(nums)):\n        for j in range(i+1,len(nums)):\n            if nums[i]+nums[j] == target:\n                return [i,j]\n    return []",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:43:58.652567",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "name 'result' is not defined",
    "raw_code": "def two_sum(numbers, target):\n    # Initialize pointers\n    left, right = 0, len(numbers) - 1\n    \n    # Iterate through the list with a while loop\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        # If the current sum is equal to the target, add the pair and return it\n        if current_sum == target:\n            result.append((numbers[left], numbers[right]))\n            return result\n        \n        # If the current sum is less than the target, move the left pointer right\n        elif current_sum < target:\n            left += 1\n            \n        # If the current sum is greater than the target, move the right pointer left\n        else:\n            right -= 1\n    \n    # Return False if no such pair was found\n    return False\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(numbers, target):\n    left, right = (0, len(numbers) - 1)\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            result.append((numbers[left], numbers[right]))\n            return result\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return False",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:44:11.489575",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(arr, k):\n    # Create an empty dictionary to store the complement of each number\n    complements = {}\n    \n    # Iterate through each number in the array\n    for num in arr:\n        # Calculate the complement needed to reach the target\n        complement = k - num\n        \n        # Check if this complement is already in the dictionary\n        if complement in complements:\n            # Return the pair of numbers that add up to the target\n            return [complements[complement], num]\n        \n        # Add the current number and its complement to the dictionary\n        complements[num] = k - num\n    \n    # If no such pair is found, return None\n    return None\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(arr, k):\n    complements = {}\n    for num in arr:\n        complement = k - num\n        if complement in complements:\n            return [complements[complement], num]\n        complements[num] = k - num\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          7,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:18.450893",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    for num in nums:\n        complement = target - num\n        if complement in nums and complement != num:\n            result.append(num)\n            result.append(complement)\n    return result\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    result = []\n    for num in nums:\n        complement = target - num\n        if complement in nums and complement != num:\n            result.append(num)\n            result.append(complement)\n    return result",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7,
          7,
          2
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:20.322526",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "'set' object has no attribute 'index'",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    This function takes a list of integers nums and an integer target.\n    It returns the indices of the two numbers that add up to the target.\n    \n    Args:\n    nums (list[int]): The list of integers.\n    target (int): The target sum to find in the list.\n    \n    Returns:\n    list: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    # Iterate through the list and use a set to track seen numbers\n    seen_numbers = set()\n    for index, num in enumerate(nums):\n        complement = target - num  # Calculate the complement needed to reach the target\n        \n        # Check if the complement exists in the seen_numbers set\n        if complement in seen_numbers:\n            return [seen_numbers.index(complement), index]\n        \n        # Add the current number to the set of seen numbers\n        seen_numbers.add(num)",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    This function takes a list of integers nums and an integer target.\n    It returns the indices of the two numbers that add up to the target.\n    \n    Args:\n    nums (list[int]): The list of integers.\n    target (int): The target sum to find in the list.\n    \n    Returns:\n    list: A list containing the indices of the two numbers that add up to the target.\n    \"\"\"\n    seen_numbers = set()\n    for index, num in enumerate(nums):\n        complement = target - num\n        if complement in seen_numbers:\n            return [seen_numbers.index(complement), index]\n        seen_numbers.add(num)",
    "test_results": []
  },
  {
    "timestamp": "2025-09-28T17:44:25.772148",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given a list of numbers and a target sum, find the two unique elements that add up to the target.\n    \n    Args:\n    nums (list[int]): The list of integers to search through.\n    target (int): The target sum to find.\n    \n    Returns:\n    list[int]: A list containing the two unique elements that add up to the target.\n    \"\"\"\n    num_set = set(nums)  # Convert the list to a set for O(1) lookups\n    for num in nums:\n        complement = target - num  # Calculate the complement of the current number with respect to the target\n        if complement in num_set:  # Check if the complement exists in the set (which contains unique numbers)\n            return [num, complement]  # Return a list containing the two numbers that sum up to the target\n    return None  # If no pair is found, return None\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]\nassert two_sum([1, 3, 4, 5, 6], 8) == [1, 7]\nassert two_sum([-1, -4, 2, 1], 2) == [-1, 2]\nassert two_sum([1, 2, 3, 7], 10) == []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    \"\"\"\n    Given a list of numbers and a target sum, find the two unique elements that add up to the target.\n    \n    Args:\n    nums (list[int]): The list of integers to search through.\n    target (int): The target sum to find.\n    \n    Returns:\n    list[int]: A list containing the two unique elements that add up to the target.\n    \"\"\"\n    num_set = set(nums)\n    for num in nums:\n        complement = target - num\n        if complement in num_set:\n            return [num, complement]\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:33.792604",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    i=0\n    j=len(nums)-1\n    while i<j:\n        if nums[i]+nums[j] == target:\n            return [i,j]\n        elif nums[i]+nums[j] > target:\n            j-=1\n        else:\n            i+=1",
    "code": "def two_sum(nums, target):\n    i = 0\n    j = len(nums) - 1\n    while i < j:\n        if nums[i] + nums[j] == target:\n            return [i, j]\n        elif nums[i] + nums[j] > target:\n            j -= 1\n        else:\n            i += 1",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:35.224055",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create a dictionary to store numbers and their indices\n    d = {}\n    \n    for i, num in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in d:\n            return [d[complement], i]\n        \n        # If not, add the current number and its index to the dictionary\n        d[num] = i\n    \n    # In case no solution is found\n    return []\n\n# Example usage:\nnums = [2, 7, 11, 15]\ntarget = 9\nresult = two_sum(nums, target)\nprint(result)  # Output: [0, 1]",
    "code": "def two_sum(nums, target):\n    d = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in d:\n            return [d[complement], i]\n        d[num] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:43.379865",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Direct",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Initialize a dictionary to store numbers as keys and their indices as values\n    d = {}\n    \n    for i in range(len(nums)):\n        # Calculate the complement (target - nums[i])\n        comp = target - nums[i]\n        \n        # Check if the complement is already in the dictionary\n        if comp in d:\n            return [d[comp], i]\n        \n        # If not, add the current number and its index to the dictionary\n        d[nums[i]] = i\n    \n    # If no solution is found, return an empty list\n    return []\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    d = {}\n    for i in range(len(nums)):\n        comp = target - nums[i]\n        if comp in d:\n            return [d[comp], i]\n        d[nums[i]] = i\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:48.621220",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Iterate through each number in the list\n    for i in range(len(nums)):\n        # Check if the complement of the current number exists in the list\n        for j in range(i + 1, len(nums)):\n            # If the numbers add up to the target, return them as a tuple\n            if nums[i] + nums[j] == target:\n                return [nums[i], nums[j]]\n    # Return an empty list if no such pair is found\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [nums[i], nums[j]]\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:44:56.247615",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(numbers, target):\n    seen = set()\n    \n    for number in numbers:\n        complement = target - number\n        \n        # Check if the complement is already in the set\n        if complement in seen:\n            return [number, complement]\n        \n        # Add the current number to the set\n        seen.add(number)\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(numbers, target):\n    seen = set()\n    for number in numbers:\n        complement = target - number\n        if complement in seen:\n            return [number, complement]\n        seen.add(number)\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          7,
          2
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:45:05.254340",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(numbers, target):\n    # Initialize two pointers: left at the start and right at the end of the list\n    left = 0\n    right = len(numbers) - 1\n    \n    # Use a while loop to find pairs that sum up to the target\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        # If the current sum equals the target, return the pair as a list\n        if current_sum == target:\n            return [left, right]\n        \n        # If the current sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the current sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    # If no such pair exists, return an empty list\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2,7,11,15], 9) == [0, 1]",
    "code": "def two_sum(numbers, target):\n    left = 0\n    right = len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:45:24.202380",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Initialize two pointers, left and right, to point to the start and end of the list respectively\n    left = 0\n    right = len(nums) - 1\n    \n    # Iterate through the list using a while loop\n    while left < right:\n        # Calculate the sum of the numbers at the two pointers\n        current_sum = nums[left] + nums[right]\n        \n        # If the sum is equal to the target, return the index of both numbers\n        if current_sum == target:\n            return [left, right]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif current_sum < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    # If no two numbers add up to the target value, return an empty list\n    return []",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:45:45.584259",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Step-by-step",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Create a set to store numbers that have been processed so far\n    seen = set()\n    \n    for num in nums:\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the set\n        if complement in seen:\n            return [seen.pop(), num]\n        \n        # Add the current number to the set\n        seen.add(num)\n    \n    # Return None if no two numbers sum up to the target\n    return None\n\n# Test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    seen = set()\n    for num in nums:\n        complement = target - num\n        if complement in seen:\n            return [seen.pop(), num]\n        seen.add(num)\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:46:07.975185",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(arr, target):\n    # Initialize a dictionary to store numbers and their indices\n    seen = {}\n    \n    # Iterate over each number in the array\n    for i, num in enumerate(arr):\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in seen:\n            return [seen[complement], i]  # Return the pair of indices that sum up to the target\n    \n        # Add the current number and its index to the dictionary\n        seen[num] = i\n\n# Test the function with the provided test case\nassert two_sum([2,7,11,15], 9) == [0,1]",
    "code": "def two_sum(arr, target):\n    seen = {}\n    for i, num in enumerate(arr):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:46:10.897888",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the list of numbers\n    nums.sort()\n    \n    # Initialize pointers\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        # Check if the current pair sums up to the target\n        if nums[left] + nums[right] == target:\n            return [nums[left], nums[right]]\n        \n        # If the sum is less than the target, move the left pointer to the right\n        elif nums[left] + nums[right] < target:\n            left += 1\n        \n        # If the sum is greater than the target, move the right pointer to the left\n        else:\n            right -= 1\n    \n    return []\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left, right = (0, len(nums) - 1)\n    while left < right:\n        if nums[left] + nums[right] == target:\n            return [nums[left], nums[right]]\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:46:21.629488",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Minimal",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    # Sort the list\n    nums.sort()\n    \n    # Initialize two pointers\n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        \n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    \n    # If no such pair is found, return an empty list\n    return []\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum > target:\n            right -= 1\n        else:\n            left += 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:46:39.321436",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Create an empty dictionary to store the complement of each number found in the list\n    complements = {}\n    \n    # Iterate through each number in the list\n    for num in nums:\n        # Calculate the complement needed to reach the target sum\n        complement = target - num\n        \n        # Check if the complement is already in the dictionary\n        if complement in complements:\n            return [complements[complement], num]\n        \n        # Add the current number and its complement to the dictionary\n        complements[num] = complement\n    \n    # If no such pair is found, return None\n    return None\n\n# Test the function with the provided test case\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    complements = {}\n    for num in nums:\n        complement = target - num\n        if complement in complements:\n            return [complements[complement], num]\n        complements[num] = complement\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          7,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:46:47.525409",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Medium",
    "output": "Code + tests + explanation",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    # Sort the array\n    nums.sort()\n    \n    left = 0\n    right = len(nums) - 1\n    \n    while left < right:\n        current_sum = nums[left] + nums[right]\n        \n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    \n    # If no pair is found, return an empty list\n    return []\n\n# Test cases\nassert two_sum([2,7,11,15], 9) == [0, 1]",
    "code": "def two_sum(nums: list[int], target: int) -> list[int]:\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left, right]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:46:57.864827",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code only",
    "passed": true,
    "error": "",
    "raw_code": "def two_sum(nums, target):\n    \"\"\"\n    Two Sum Solution\n    :param nums: List[int] - Input list of integers.\n    :param target: int - Target sum to find in the list.\n    :return: List[int] - A list containing indices of the two numbers that add up to target.\n    \"\"\"\n    # Create a dictionary to store elements and their indices\n    lookup = {}\n    \n    for index, value in enumerate(nums):\n        # Calculate the complement needed to reach the target\n        complement = target - value\n        \n        # Check if the complement is already in the dictionary\n        if complement in lookup:\n            return [lookup[complement], index]\n        \n        # If not, add the current element and its index to the dictionary\n        lookup[value] = index\n\n    # Return an empty list if no solution exists\n    return []",
    "code": "def two_sum(nums, target):\n    \"\"\"\n    Two Sum Solution\n    :param nums: List[int] - Input list of integers.\n    :param target: int - Target sum to find in the list.\n    :return: List[int] - A list containing indices of the two numbers that add up to target.\n    \"\"\"\n    lookup = {}\n    for index, value in enumerate(nums):\n        complement = target - value\n        if complement in lookup:\n            return [lookup[complement], index]\n        lookup[value] = index\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:47:01.352225",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + explanation",
    "passed": true,
    "error": "",
    "raw_code": "# Define the function to find two numbers that add up to the target\ndef two_sum(nums, target):\n    # Create an empty dictionary to store the numbers we have seen so far\n    num_dict = {}\n    \n    # Iterate through each number in the list\n    for i in range(len(nums)):\n        # Calculate the complement of the current number with the target\n        complement = target - nums[i]\n        \n        # Check if the complement is already in the dictionary\n        if complement in num_dict:\n            # If found, return the pair of numbers\n            return [num_dict[complement], i]\n        \n        # Add the current number to the dictionary with its index\n        num_dict[nums[i]] = i\n    \n    # If no pair is found, return None or raise an exception if necessary\n    return None\n\n# Test the function with the provided test cases\nassert two_sum([2, 7, 11, 15], 9) == [0, 1]",
    "code": "def two_sum(nums, target):\n    num_dict = {}\n    for i in range(len(nums)):\n        complement = target - nums[i]\n        if complement in num_dict:\n            return [num_dict[complement], i]\n        num_dict[nums[i]] = i\n    return None",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          0,
          1
        ],
        "expected": [
          0,
          1
        ],
        "passed": true
      }
    ]
  },
  {
    "timestamp": "2025-09-28T17:47:09.513341",
    "problem": "Easy \u2013 Two Sum",
    "framing": "Test-driven",
    "scaffold": "Self-checking",
    "verbosity": "Verbose",
    "output": "Code + tests + explanation",
    "passed": false,
    "error": "",
    "raw_code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    # Create a dictionary to store the numbers we have seen so far.\n    memo = {}\n    \n    # Iterate through each number in the list.\n    for num in nums:\n        # Calculate the complement that would add up with the current number to reach the target.\n        complement = target - num\n        \n        # Check if the complement is already in our dictionary. If it is, we have found a solution.\n        if complement in memo:\n            return [memo[complement], num]\n        \n        # Store the current number and its complement in our dictionary for future use.\n        memo[num] = num\n    \n    # If no solution is found after checking all numbers, return an empty list.\n    return []",
    "code": "def two_sum(nums: List[int], target: int) -> List[int]:\n    memo = {}\n    for num in nums:\n        complement = target - num\n        if complement in memo:\n            return [memo[complement], num]\n        memo[num] = num\n    return []",
    "test_results": [
      {
        "test": "two_sum([2, 7, 11, 15], 9) == [0, 1]",
        "actual": [
          2,
          7
        ],
        "expected": [
          0,
          1
        ],
        "passed": false
      }
    ]
  }
]